import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, K as validate_each_argument, v as validate_store, c as component_subscribe, a as validate_slots, f as element, F as text, h as space, j as claim_element, k as children, G as claim_text, l as detach_dev, m as claim_space, n as attr_dev, p as add_location, t as insert_dev, r as append_dev, L as set_data_dev, u as noop, M as destroy_each, b as authUserStore, H as listen_dev, N as set_input_value, O as createEventDispatcher, P as onDestroy, Q as prop_dev, R as add_render_callback, T as select_option, I as run_all, U as select_value, w as create_component, x as claim_component, y as mount_component, B as transition_in, z as transition_out, C as destroy_component, E as group_outros, A as check_outros, V as subscribe, W as to_number, D as set_store_value, g as globals, X as empty } from './client.ac32a3b6.js';
import { c as character } from './characterStore.4f6031d2.js';
import './SWBodyguard.54177d3a.js';
import { A as AccessoryList, a as AmmoList, b as ArmorList, B as BombList } from './BombList.4927c2b7.js';
import { D as DocumentList, a as DrugList, E as ElectronicList, M as MiscList, b as MedicalList, S as StorageList } from './StorageList.71288974.js';
import { M as MeleeWeaponList, R as RangedWeaponList } from './AppendToGUUID.176d1458.js';
import { P as PropSort } from './Skills.35c4252b.js';
import { A as AmmoList$1, a as ArmorList$1, E as EquipmentList, M as MeleeWeaponList$1, R as RangedWeaponList$1 } from './RangedWeaponList.4703ea51.js';
import { G as GearBlock } from './GearBlock.d255c85a.js';
import './Abilities.5f272c11.js';
import './Speed.66ad8113.js';

/* src/components/views/character/Abilities.svelte generated by Svelte v3.29.0 */
const file = "src/components/views/character/Abilities.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (18:3) {#each $character.abilities as ability}
function create_each_block(ctx) {
	let div;
	let span0;
	let t0_value = /*ability*/ ctx[1].name + "";
	let t0;

	let t1_value = (/*ability*/ ctx[1].opts[0]
	? ` (${/*ability*/ ctx[1].opts[0].name})`
	: ``) + "";

	let t1;
	let t2;
	let span1;
	let t3_value = /*ability*/ ctx[1].xp + "";
	let t3;
	let t4;
	let span2;
	let t5_value = /*ability*/ ctx[1].max + "";
	let t5;
	let t6;
	let span3;
	let t7_value = /*ability*/ ctx[1].taken + "";
	let t7;
	let t8;

	const block = {
		c: function create() {
			div = element("div");
			span0 = element("span");
			t0 = text(t0_value);
			t1 = text(t1_value);
			t2 = space();
			span1 = element("span");
			t3 = text(t3_value);
			t4 = space();
			span2 = element("span");
			t5 = text(t5_value);
			t6 = space();
			span3 = element("span");
			t7 = text(t7_value);
			t8 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span0 = claim_element(div_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, t0_value);
			t1 = claim_text(span0_nodes, t1_value);
			span0_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			span1 = claim_element(div_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t3 = claim_text(span1_nodes, t3_value);
			span1_nodes.forEach(detach_dev);
			t4 = claim_space(div_nodes);
			span2 = claim_element(div_nodes, "SPAN", { class: true });
			var span2_nodes = children(span2);
			t5 = claim_text(span2_nodes, t5_value);
			span2_nodes.forEach(detach_dev);
			t6 = claim_space(div_nodes);
			span3 = claim_element(div_nodes, "SPAN", { class: true });
			var span3_nodes = children(span3);
			t7 = claim_text(span3_nodes, t7_value);
			span3_nodes.forEach(detach_dev);
			t8 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "sheet-item-long-column");
			add_location(span0, file, 19, 5, 583);
			attr_dev(span1, "class", "sheet-item-short-column");
			add_location(span1, file, 22, 5, 713);
			attr_dev(span2, "class", "sheet-item-short-column");
			add_location(span2, file, 25, 5, 789);
			attr_dev(span3, "class", "sheet-item-short-column");
			add_location(span3, file, 28, 5, 866);
			attr_dev(div, "class", "sheet-card-table-row");
			add_location(div, file, 18, 4, 543);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span0);
			append_dev(span0, t0);
			append_dev(span0, t1);
			append_dev(div, t2);
			append_dev(div, span1);
			append_dev(span1, t3);
			append_dev(div, t4);
			append_dev(div, span2);
			append_dev(span2, t5);
			append_dev(div, t6);
			append_dev(div, span3);
			append_dev(span3, t7);
			append_dev(div, t8);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 1 && t0_value !== (t0_value = /*ability*/ ctx[1].name + "")) set_data_dev(t0, t0_value);

			if (dirty & /*$character*/ 1 && t1_value !== (t1_value = (/*ability*/ ctx[1].opts[0]
			? ` (${/*ability*/ ctx[1].opts[0].name})`
			: ``) + "")) set_data_dev(t1, t1_value);

			if (dirty & /*$character*/ 1 && t3_value !== (t3_value = /*ability*/ ctx[1].xp + "")) set_data_dev(t3, t3_value);
			if (dirty & /*$character*/ 1 && t5_value !== (t5_value = /*ability*/ ctx[1].max + "")) set_data_dev(t5, t5_value);
			if (dirty & /*$character*/ 1 && t7_value !== (t7_value = /*ability*/ ctx[1].taken + "")) set_data_dev(t7, t7_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(18:3) {#each $character.abilities as ability}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let details;
	let summary;
	let t0;
	let t1;
	let div2;
	let div1;
	let div0;
	let span0;
	let t2;
	let t3;
	let span1;
	let t4;
	let t5;
	let span2;
	let t6;
	let t7;
	let span3;
	let t8;
	let t9;
	let each_value = /*$character*/ ctx[0].abilities;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			details = element("details");
			summary = element("summary");
			t0 = text("Abilities");
			t1 = space();
			div2 = element("div");
			div1 = element("div");
			div0 = element("div");
			span0 = element("span");
			t2 = text("Name");
			t3 = space();
			span1 = element("span");
			t4 = text("XP");
			t5 = space();
			span2 = element("span");
			t6 = text("Max");
			t7 = space();
			span3 = element("span");
			t8 = text("Taken");
			t9 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			details = claim_element(nodes, "DETAILS", { class: true, close: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", { class: true });
			var summary_nodes = children(summary);
			t0 = claim_text(summary_nodes, "Abilities");
			summary_nodes.forEach(detach_dev);
			t1 = claim_space(details_nodes);
			div2 = claim_element(details_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span0 = claim_element(div0_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t2 = claim_text(span0_nodes, "Name");
			span0_nodes.forEach(detach_dev);
			t3 = claim_space(div0_nodes);
			span1 = claim_element(div0_nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t4 = claim_text(span1_nodes, "XP");
			span1_nodes.forEach(detach_dev);
			t5 = claim_space(div0_nodes);
			span2 = claim_element(div0_nodes, "SPAN", { class: true });
			var span2_nodes = children(span2);
			t6 = claim_text(span2_nodes, "Max");
			span2_nodes.forEach(detach_dev);
			t7 = claim_space(div0_nodes);
			span3 = claim_element(div0_nodes, "SPAN", { class: true });
			var span3_nodes = children(span3);
			t8 = claim_text(span3_nodes, "Taken");
			span3_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t9 = claim_space(div1_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			details_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(summary, "class", "sheet-card-title");
			add_location(summary, file, 6, 1, 114);
			attr_dev(span0, "class", "sheet-item-long-column");
			add_location(span0, file, 12, 4, 277);
			attr_dev(span1, "class", "sheet-item-short-column");
			add_location(span1, file, 13, 4, 330);
			attr_dev(span2, "class", "sheet-item-short-column");
			add_location(span2, file, 14, 4, 382);
			attr_dev(span3, "class", "sheet-item-short-column");
			add_location(span3, file, 15, 4, 435);
			attr_dev(div0, "class", "sheet-card-table-header");
			add_location(div0, file, 11, 3, 235);
			attr_dev(div1, "class", "sheet-card-table");
			add_location(div1, file, 10, 2, 201);
			attr_dev(div2, "class", "sheet-card");
			add_location(div2, file, 9, 1, 174);
			attr_dev(details, "class", "sheet-details");
			attr_dev(details, "close", "");
			add_location(details, file, 5, 0, 75);
		},
		m: function mount(target, anchor) {
			insert_dev(target, details, anchor);
			append_dev(details, summary);
			append_dev(summary, t0);
			append_dev(details, t1);
			append_dev(details, div2);
			append_dev(div2, div1);
			append_dev(div1, div0);
			append_dev(div0, span0);
			append_dev(span0, t2);
			append_dev(div0, t3);
			append_dev(div0, span1);
			append_dev(span1, t4);
			append_dev(div0, t5);
			append_dev(div0, span2);
			append_dev(span2, t6);
			append_dev(div0, t7);
			append_dev(div0, span3);
			append_dev(span3, t8);
			append_dev(div1, t9);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$character*/ 1) {
				each_value = /*$character*/ ctx[0].abilities;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(details);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(0, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Abilities", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Abilities> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ character, $character });
	return [$character];
}

class Abilities extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Abilities",
			options,
			id: create_fragment.name
		});
	}
}

var DeleteCharacter = (character) => {
	return fetch(
		`/.netlify/functions/character-delete`, {
			method: `POST`,
			body: JSON.stringify(character.id)
		}
	).then(res => res.json())
};

/* src/components/views/character/DeleteCharacterButton.svelte generated by Svelte v3.29.0 */
const file$1 = "src/components/views/character/DeleteCharacterButton.svelte";

function create_fragment$1(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text("Delete");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Delete");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "small-cntr-btn");
			add_location(button, file$1, 10, 0, 226);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*deleteCharacter*/ ctx[0], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $authUserStore;
	validate_store(authUserStore, "authUserStore");
	component_subscribe($$self, authUserStore, $$value => $$invalidate(1, $authUserStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DeleteCharacterButton", slots, []);

	const deleteCharacter = () => {
		DeleteCharacter($authUserStore.id);
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DeleteCharacterButton> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		DeleteCharacter,
		authUserStore,
		deleteCharacter,
		$authUserStore
	});

	return [deleteCharacter];
}

class DeleteCharacterButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DeleteCharacterButton",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src/components/views/character/Description.svelte generated by Svelte v3.29.0 */
const file$2 = "src/components/views/character/Description.svelte";

// (17:32) 
function create_if_block_13(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true, readonly: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value-long svelte-w4qo79");
			input.readOnly = true;
			add_location(input, file$2, 17, 4, 426);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.name.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[3]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.name.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.name.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_13.name,
		type: "if",
		source: "(17:32) ",
		ctx
	});

	return block;
}

// (15:3) {#if mode == 'edit'}
function create_if_block_12(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value-long svelte-w4qo79");
			add_location(input, file$2, 15, 4, 302);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.name.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[2]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.name.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.name.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12.name,
		type: "if",
		source: "(15:3) {#if mode == 'edit'}",
		ctx
	});

	return block;
}

// (27:34) 
function create_if_block_11(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true, readonly: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			input.readOnly = true;
			add_location(input, file$2, 27, 6, 818);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.age.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_3*/ ctx[5]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.age.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.age.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11.name,
		type: "if",
		source: "(27:34) ",
		ctx
	});

	return block;
}

// (25:5) {#if mode == 'edit'}
function create_if_block_10(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			add_location(input, file$2, 25, 6, 696);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.age.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_2*/ ctx[4]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.age.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.age.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(25:5) {#if mode == 'edit'}",
		ctx
	});

	return block;
}

// (35:34) 
function create_if_block_9(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true, readonly: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			input.readOnly = true;
			add_location(input, file$2, 35, 6, 1148);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.height.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_5*/ ctx[7]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.height.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.height.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(35:34) ",
		ctx
	});

	return block;
}

// (33:5) {#if mode == 'edit'}
function create_if_block_8(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			add_location(input, file$2, 33, 6, 1023);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.height.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_4*/ ctx[6]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.height.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.height.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(33:5) {#if mode == 'edit'}",
		ctx
	});

	return block;
}

// (43:34) 
function create_if_block_7(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true, readonly: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			input.readOnly = true;
			add_location(input, file$2, 43, 6, 1481);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.weight.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_7*/ ctx[9]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.weight.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.weight.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(43:34) ",
		ctx
	});

	return block;
}

// (41:5) {#if mode == 'edit'}
function create_if_block_6(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			add_location(input, file$2, 41, 6, 1356);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.weight.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_6*/ ctx[8]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.weight.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.weight.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(41:5) {#if mode == 'edit'}",
		ctx
	});

	return block;
}

// (53:34) 
function create_if_block_5(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true, readonly: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			input.readOnly = true;
			add_location(input, file$2, 53, 6, 1851);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.sex.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_9*/ ctx[11]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.sex.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.sex.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(53:34) ",
		ctx
	});

	return block;
}

// (51:5) {#if mode == 'edit'}
function create_if_block_4(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			add_location(input, file$2, 51, 6, 1729);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.sex.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_8*/ ctx[10]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.sex.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.sex.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(51:5) {#if mode == 'edit'}",
		ctx
	});

	return block;
}

// (61:34) 
function create_if_block_3(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true, readonly: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			input.readOnly = true;
			add_location(input, file$2, 61, 6, 2176);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.skin.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_11*/ ctx[13]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.skin.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.skin.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(61:34) ",
		ctx
	});

	return block;
}

// (59:5) {#if mode == 'edit'}
function create_if_block_2(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			add_location(input, file$2, 59, 6, 2053);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.skin.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_10*/ ctx[12]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.skin.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.skin.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(59:5) {#if mode == 'edit'}",
		ctx
	});

	return block;
}

// (69:34) 
function create_if_block_1(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true, readonly: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			input.readOnly = true;
			add_location(input, file$2, 69, 6, 2502);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.hair.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_13*/ ctx[15]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.hair.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.hair.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(69:34) ",
		ctx
	});

	return block;
}

// (67:5) {#if mode == 'edit'}
function create_if_block(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", { type: true, class: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "text");
			attr_dev(input, "class", "sheet-value svelte-w4qo79");
			add_location(input, file$2, 67, 6, 2379);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].desc.hair.value);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_12*/ ctx[14]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input.value !== /*$character*/ ctx[1].desc.hair.value) {
				set_input_value(input, /*$character*/ ctx[1].desc.hair.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(67:5) {#if mode == 'edit'}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let details;
	let summary;
	let t0;
	let t1;
	let div10;
	let div0;
	let span0;
	let t2;
	let t3;
	let t4;
	let div9;
	let div4;
	let div1;
	let span1;
	let t5;
	let t6;
	let t7;
	let div2;
	let span2;
	let t8;
	let t9;
	let t10;
	let div3;
	let span3;
	let t11;
	let t12;
	let t13;
	let div8;
	let div5;
	let span4;
	let t14;
	let t15;
	let t16;
	let div6;
	let span5;
	let t17;
	let t18;
	let t19;
	let div7;
	let span6;
	let t20;
	let t21;

	function select_block_type(ctx, dirty) {
		if (/*mode*/ ctx[0] == "edit") return create_if_block_12;
		if (/*mode*/ ctx[0] == "readonly") return create_if_block_13;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type && current_block_type(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*mode*/ ctx[0] == "edit") return create_if_block_10;
		if (/*mode*/ ctx[0] == "readonly") return create_if_block_11;
	}

	let current_block_type_1 = select_block_type_1(ctx);
	let if_block1 = current_block_type_1 && current_block_type_1(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*mode*/ ctx[0] == "edit") return create_if_block_8;
		if (/*mode*/ ctx[0] == "readonly") return create_if_block_9;
	}

	let current_block_type_2 = select_block_type_2(ctx);
	let if_block2 = current_block_type_2 && current_block_type_2(ctx);

	function select_block_type_3(ctx, dirty) {
		if (/*mode*/ ctx[0] == "edit") return create_if_block_6;
		if (/*mode*/ ctx[0] == "readonly") return create_if_block_7;
	}

	let current_block_type_3 = select_block_type_3(ctx);
	let if_block3 = current_block_type_3 && current_block_type_3(ctx);

	function select_block_type_4(ctx, dirty) {
		if (/*mode*/ ctx[0] == "edit") return create_if_block_4;
		if (/*mode*/ ctx[0] == "readonly") return create_if_block_5;
	}

	let current_block_type_4 = select_block_type_4(ctx);
	let if_block4 = current_block_type_4 && current_block_type_4(ctx);

	function select_block_type_5(ctx, dirty) {
		if (/*mode*/ ctx[0] == "edit") return create_if_block_2;
		if (/*mode*/ ctx[0] == "readonly") return create_if_block_3;
	}

	let current_block_type_5 = select_block_type_5(ctx);
	let if_block5 = current_block_type_5 && current_block_type_5(ctx);

	function select_block_type_6(ctx, dirty) {
		if (/*mode*/ ctx[0] == "edit") return create_if_block;
		if (/*mode*/ ctx[0] == "readonly") return create_if_block_1;
	}

	let current_block_type_6 = select_block_type_6(ctx);
	let if_block6 = current_block_type_6 && current_block_type_6(ctx);

	const block = {
		c: function create() {
			details = element("details");
			summary = element("summary");
			t0 = text("Description");
			t1 = space();
			div10 = element("div");
			div0 = element("div");
			span0 = element("span");
			t2 = text("Character:");
			t3 = space();
			if (if_block0) if_block0.c();
			t4 = space();
			div9 = element("div");
			div4 = element("div");
			div1 = element("div");
			span1 = element("span");
			t5 = text("Age:");
			t6 = space();
			if (if_block1) if_block1.c();
			t7 = space();
			div2 = element("div");
			span2 = element("span");
			t8 = text("Height:");
			t9 = space();
			if (if_block2) if_block2.c();
			t10 = space();
			div3 = element("div");
			span3 = element("span");
			t11 = text("Weight:");
			t12 = space();
			if (if_block3) if_block3.c();
			t13 = space();
			div8 = element("div");
			div5 = element("div");
			span4 = element("span");
			t14 = text("Sex:");
			t15 = space();
			if (if_block4) if_block4.c();
			t16 = space();
			div6 = element("div");
			span5 = element("span");
			t17 = text("Skin:");
			t18 = space();
			if (if_block5) if_block5.c();
			t19 = space();
			div7 = element("div");
			span6 = element("span");
			t20 = text("Hair:");
			t21 = space();
			if (if_block6) if_block6.c();
			this.h();
		},
		l: function claim(nodes) {
			details = claim_element(nodes, "DETAILS", { class: true, close: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", { class: true });
			var summary_nodes = children(summary);
			t0 = claim_text(summary_nodes, "Description");
			summary_nodes.forEach(detach_dev);
			t1 = claim_space(details_nodes);
			div10 = claim_element(details_nodes, "DIV", { class: true });
			var div10_nodes = children(div10);
			div0 = claim_element(div10_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span0 = claim_element(div0_nodes, "SPAN", {});
			var span0_nodes = children(span0);
			t2 = claim_text(span0_nodes, "Character:");
			span0_nodes.forEach(detach_dev);
			t3 = claim_space(div0_nodes);
			if (if_block0) if_block0.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t4 = claim_space(div10_nodes);
			div9 = claim_element(div10_nodes, "DIV", { class: true });
			var div9_nodes = children(div9);
			div4 = claim_element(div9_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div1 = claim_element(div4_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			span1 = claim_element(div1_nodes, "SPAN", {});
			var span1_nodes = children(span1);
			t5 = claim_text(span1_nodes, "Age:");
			span1_nodes.forEach(detach_dev);
			t6 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t7 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			span2 = claim_element(div2_nodes, "SPAN", {});
			var span2_nodes = children(span2);
			t8 = claim_text(span2_nodes, "Height:");
			span2_nodes.forEach(detach_dev);
			t9 = claim_space(div2_nodes);
			if (if_block2) if_block2.l(div2_nodes);
			div2_nodes.forEach(detach_dev);
			t10 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			span3 = claim_element(div3_nodes, "SPAN", {});
			var span3_nodes = children(span3);
			t11 = claim_text(span3_nodes, "Weight:");
			span3_nodes.forEach(detach_dev);
			t12 = claim_space(div3_nodes);
			if (if_block3) if_block3.l(div3_nodes);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			t13 = claim_space(div9_nodes);
			div8 = claim_element(div9_nodes, "DIV", { class: true });
			var div8_nodes = children(div8);
			div5 = claim_element(div8_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			span4 = claim_element(div5_nodes, "SPAN", {});
			var span4_nodes = children(span4);
			t14 = claim_text(span4_nodes, "Sex:");
			span4_nodes.forEach(detach_dev);
			t15 = claim_space(div5_nodes);
			if (if_block4) if_block4.l(div5_nodes);
			div5_nodes.forEach(detach_dev);
			t16 = claim_space(div8_nodes);
			div6 = claim_element(div8_nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			span5 = claim_element(div6_nodes, "SPAN", {});
			var span5_nodes = children(span5);
			t17 = claim_text(span5_nodes, "Skin:");
			span5_nodes.forEach(detach_dev);
			t18 = claim_space(div6_nodes);
			if (if_block5) if_block5.l(div6_nodes);
			div6_nodes.forEach(detach_dev);
			t19 = claim_space(div8_nodes);
			div7 = claim_element(div8_nodes, "DIV", { class: true });
			var div7_nodes = children(div7);
			span6 = claim_element(div7_nodes, "SPAN", {});
			var span6_nodes = children(span6);
			t20 = claim_text(span6_nodes, "Hair:");
			span6_nodes.forEach(detach_dev);
			t21 = claim_space(div7_nodes);
			if (if_block6) if_block6.l(div7_nodes);
			div7_nodes.forEach(detach_dev);
			div8_nodes.forEach(detach_dev);
			div9_nodes.forEach(detach_dev);
			div10_nodes.forEach(detach_dev);
			details_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(summary, "class", "sheet-card-title");
			add_location(summary, file$2, 8, 1, 132);
			add_location(span0, file$2, 13, 3, 249);
			attr_dev(div0, "class", "name-block svelte-w4qo79");
			add_location(div0, file$2, 12, 2, 221);
			add_location(span1, file$2, 23, 5, 645);
			attr_dev(div1, "class", "sheet-card-item svelte-w4qo79");
			add_location(div1, file$2, 22, 4, 610);
			add_location(span2, file$2, 31, 5, 969);
			attr_dev(div2, "class", "sheet-card-item svelte-w4qo79");
			add_location(div2, file$2, 30, 4, 934);
			add_location(span3, file$2, 39, 5, 1302);
			attr_dev(div3, "class", "sheet-card-item svelte-w4qo79");
			add_location(div3, file$2, 38, 4, 1267);
			attr_dev(div4, "class", "sheet-card-block");
			add_location(div4, file$2, 21, 3, 575);
			add_location(span4, file$2, 49, 5, 1679);
			attr_dev(div5, "class", "sheet-card-item svelte-w4qo79");
			add_location(div5, file$2, 48, 4, 1644);
			add_location(span5, file$2, 57, 5, 2002);
			attr_dev(div6, "class", "sheet-card-item svelte-w4qo79");
			add_location(div6, file$2, 56, 4, 1967);
			add_location(span6, file$2, 65, 5, 2328);
			attr_dev(div7, "class", "sheet-card-item svelte-w4qo79");
			add_location(div7, file$2, 64, 4, 2293);
			attr_dev(div8, "class", "sheet-card-block");
			add_location(div8, file$2, 47, 3, 1609);
			attr_dev(div9, "class", "sheet-card-body");
			add_location(div9, file$2, 20, 2, 542);
			attr_dev(div10, "class", "sheet-card");
			add_location(div10, file$2, 11, 1, 194);
			attr_dev(details, "class", "sheet-details");
			attr_dev(details, "close", "");
			add_location(details, file$2, 7, 0, 93);
		},
		m: function mount(target, anchor) {
			insert_dev(target, details, anchor);
			append_dev(details, summary);
			append_dev(summary, t0);
			append_dev(details, t1);
			append_dev(details, div10);
			append_dev(div10, div0);
			append_dev(div0, span0);
			append_dev(span0, t2);
			append_dev(div0, t3);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div10, t4);
			append_dev(div10, div9);
			append_dev(div9, div4);
			append_dev(div4, div1);
			append_dev(div1, span1);
			append_dev(span1, t5);
			append_dev(div1, t6);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div4, t7);
			append_dev(div4, div2);
			append_dev(div2, span2);
			append_dev(span2, t8);
			append_dev(div2, t9);
			if (if_block2) if_block2.m(div2, null);
			append_dev(div4, t10);
			append_dev(div4, div3);
			append_dev(div3, span3);
			append_dev(span3, t11);
			append_dev(div3, t12);
			if (if_block3) if_block3.m(div3, null);
			append_dev(div9, t13);
			append_dev(div9, div8);
			append_dev(div8, div5);
			append_dev(div5, span4);
			append_dev(span4, t14);
			append_dev(div5, t15);
			if (if_block4) if_block4.m(div5, null);
			append_dev(div8, t16);
			append_dev(div8, div6);
			append_dev(div6, span5);
			append_dev(span5, t17);
			append_dev(div6, t18);
			if (if_block5) if_block5.m(div6, null);
			append_dev(div8, t19);
			append_dev(div8, div7);
			append_dev(div7, span6);
			append_dev(span6, t20);
			append_dev(div7, t21);
			if (if_block6) if_block6.m(div7, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div0, null);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if (if_block1) if_block1.d(1);
				if_block1 = current_block_type_1 && current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div1, null);
				}
			}

			if (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if (if_block2) if_block2.d(1);
				if_block2 = current_block_type_2 && current_block_type_2(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(div2, null);
				}
			}

			if (current_block_type_3 === (current_block_type_3 = select_block_type_3(ctx)) && if_block3) {
				if_block3.p(ctx, dirty);
			} else {
				if (if_block3) if_block3.d(1);
				if_block3 = current_block_type_3 && current_block_type_3(ctx);

				if (if_block3) {
					if_block3.c();
					if_block3.m(div3, null);
				}
			}

			if (current_block_type_4 === (current_block_type_4 = select_block_type_4(ctx)) && if_block4) {
				if_block4.p(ctx, dirty);
			} else {
				if (if_block4) if_block4.d(1);
				if_block4 = current_block_type_4 && current_block_type_4(ctx);

				if (if_block4) {
					if_block4.c();
					if_block4.m(div5, null);
				}
			}

			if (current_block_type_5 === (current_block_type_5 = select_block_type_5(ctx)) && if_block5) {
				if_block5.p(ctx, dirty);
			} else {
				if (if_block5) if_block5.d(1);
				if_block5 = current_block_type_5 && current_block_type_5(ctx);

				if (if_block5) {
					if_block5.c();
					if_block5.m(div6, null);
				}
			}

			if (current_block_type_6 === (current_block_type_6 = select_block_type_6(ctx)) && if_block6) {
				if_block6.p(ctx, dirty);
			} else {
				if (if_block6) if_block6.d(1);
				if_block6 = current_block_type_6 && current_block_type_6(ctx);

				if (if_block6) {
					if_block6.c();
					if_block6.m(div7, null);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(details);

			if (if_block0) {
				if_block0.d();
			}

			if (if_block1) {
				if_block1.d();
			}

			if (if_block2) {
				if_block2.d();
			}

			if (if_block3) {
				if_block3.d();
			}

			if (if_block4) {
				if_block4.d();
			}

			if (if_block5) {
				if_block5.d();
			}

			if (if_block6) {
				if_block6.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(1, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Description", slots, []);
	let { mode } = $$props;
	const writable_props = ["mode"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Description> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		$character.desc.name.value = this.value;
		character.set($character);
	}

	function input_input_handler_1() {
		$character.desc.name.value = this.value;
		character.set($character);
	}

	function input_input_handler_2() {
		$character.desc.age.value = this.value;
		character.set($character);
	}

	function input_input_handler_3() {
		$character.desc.age.value = this.value;
		character.set($character);
	}

	function input_input_handler_4() {
		$character.desc.height.value = this.value;
		character.set($character);
	}

	function input_input_handler_5() {
		$character.desc.height.value = this.value;
		character.set($character);
	}

	function input_input_handler_6() {
		$character.desc.weight.value = this.value;
		character.set($character);
	}

	function input_input_handler_7() {
		$character.desc.weight.value = this.value;
		character.set($character);
	}

	function input_input_handler_8() {
		$character.desc.sex.value = this.value;
		character.set($character);
	}

	function input_input_handler_9() {
		$character.desc.sex.value = this.value;
		character.set($character);
	}

	function input_input_handler_10() {
		$character.desc.skin.value = this.value;
		character.set($character);
	}

	function input_input_handler_11() {
		$character.desc.skin.value = this.value;
		character.set($character);
	}

	function input_input_handler_12() {
		$character.desc.hair.value = this.value;
		character.set($character);
	}

	function input_input_handler_13() {
		$character.desc.hair.value = this.value;
		character.set($character);
	}

	$$self.$$set = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	$$self.$capture_state = () => ({ character, mode, $character });

	$$self.$inject_state = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		mode,
		$character,
		input_input_handler,
		input_input_handler_1,
		input_input_handler_2,
		input_input_handler_3,
		input_input_handler_4,
		input_input_handler_5,
		input_input_handler_6,
		input_input_handler_7,
		input_input_handler_8,
		input_input_handler_9,
		input_input_handler_10,
		input_input_handler_11,
		input_input_handler_12,
		input_input_handler_13
	];
}

class Description extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { mode: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Description",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*mode*/ ctx[0] === undefined && !("mode" in props)) {
			console.warn("<Description> was created without expected prop 'mode'");
		}
	}

	get mode() {
		throw new Error("<Description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<Description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const GearList = {
	name: `Gear`,
	list: [
		...AccessoryList,
		...AmmoList,
		...ArmorList,
		...BombList,
		...DocumentList,
		...DrugList,
		...ElectronicList,
		...MiscList,
		...MedicalList,
		...MeleeWeaponList,
		...RangedWeaponList,
		...StorageList,
		// ...VehicleList,
	].sort((a, b) => PropSort(a, b, `name`)),
	categories: [
		'melee',
		'ranged',
		'ammo',
		'armor',
		'equipment'
	]
};

/* src/components/views/character/AddItemModal.svelte generated by Svelte v3.29.0 */
const file$3 = "src/components/views/character/AddItemModal.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[12] = list[i];
	return child_ctx;
}

// (44:3) {#each itemList as item}
function create_each_block$1(ctx) {
	let option;
	let t_value = /*item*/ ctx[12].name + "";
	let t;
	let option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			option = claim_element(nodes, "OPTION", { value: true, class: true });
			var option_nodes = children(option);
			t = claim_text(option_nodes, t_value);
			option_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			option.__value = option_value_value = /*item*/ ctx[12];
			option.value = option.__value;
			attr_dev(option, "class", "svelte-klgtfo");
			add_location(option, file$3, 44, 4, 1556);
		},
		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*itemList*/ 1 && t_value !== (t_value = /*item*/ ctx[12].name + "")) set_data_dev(t, t_value);

			if (dirty & /*itemList*/ 1 && option_value_value !== (option_value_value = /*item*/ ctx[12])) {
				prop_dev(option, "__value", option_value_value);
				option.value = option.__value;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(44:3) {#each itemList as item}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div0;
	let t0;
	let div3;
	let div1;
	let select;
	let t1;
	let div2;
	let button0;
	let t2;
	let t3;
	let button1;
	let t4;
	let mounted;
	let dispose;
	let each_value = /*itemList*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div0 = element("div");
			t0 = space();
			div3 = element("div");
			div1 = element("div");
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			div2 = element("div");
			button0 = element("button");
			t2 = text("Add");
			t3 = space();
			button1 = element("button");
			t4 = text("Close");
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			children(div0).forEach(detach_dev);
			t0 = claim_space(nodes);

			div3 = claim_element(nodes, "DIV", {
				class: true,
				role: true,
				"aria-modal": true
			});

			var div3_nodes = children(div3);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			select = claim_element(div1_nodes, "SELECT", { class: true });
			var select_nodes = children(select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(select_nodes);
			}

			select_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t1 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			button0 = claim_element(div2_nodes, "BUTTON", { class: true });
			var button0_nodes = children(button0);
			t2 = claim_text(button0_nodes, "Add");
			button0_nodes.forEach(detach_dev);
			t3 = claim_space(div2_nodes);
			button1 = claim_element(div2_nodes, "BUTTON", { class: true });
			var button1_nodes = children(button1);
			t4 = claim_text(button1_nodes, "Close");
			button1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "modal-background svelte-klgtfo");
			add_location(div0, file$3, 39, 0, 1311);
			attr_dev(select, "class", "item-selector svelte-klgtfo");
			if (/*selectedItem*/ ctx[1] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[7].call(select));
			add_location(select, file$3, 42, 2, 1467);
			attr_dev(div1, "class", "item-selection svelte-klgtfo");
			add_location(div1, file$3, 41, 1, 1436);
			attr_dev(button0, "class", "small-cntr-btn svelte-klgtfo");
			add_location(button0, file$3, 49, 2, 1656);
			attr_dev(button1, "class", "small-cntr-btn svelte-klgtfo");
			add_location(button1, file$3, 50, 2, 1725);
			attr_dev(div2, "class", "btn-row svelte-klgtfo");
			add_location(div2, file$3, 48, 1, 1632);
			attr_dev(div3, "class", "modal svelte-klgtfo");
			attr_dev(div3, "role", "dialog");
			attr_dev(div3, "aria-modal", "true");
			add_location(div3, file$3, 40, 0, 1383);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div3, anchor);
			append_dev(div3, div1);
			append_dev(div1, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(select, null);
			}

			select_option(select, /*selectedItem*/ ctx[1]);
			append_dev(div3, t1);
			append_dev(div3, div2);
			append_dev(div2, button0);
			append_dev(button0, t2);
			append_dev(div2, t3);
			append_dev(div2, button1);
			append_dev(button1, t4);

			if (!mounted) {
				dispose = [
					listen_dev(window, "keydown", /*handleKeydown*/ ctx[3], false, false, false),
					listen_dev(div0, "click", /*click_handler*/ ctx[6], false, false, false),
					listen_dev(select, "change", /*select_change_handler*/ ctx[7]),
					listen_dev(button0, "click", /*click_handler_1*/ ctx[8], false, false, false),
					listen_dev(button1, "click", /*click_handler_2*/ ctx[9], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*itemList*/ 1) {
				each_value = /*itemList*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty & /*selectedItem, itemList*/ 3) {
				select_option(select, /*selectedItem*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div3);
			destroy_each(each_blocks, detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(10, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("AddItemModal", slots, []);
	let { category } = $$props;
	let itemList = [];
	if (category == "melee") itemList = [...MeleeWeaponList$1]; else if (category == "ranged") itemList = [...RangedWeaponList$1]; else if (category == "ammo") itemList = [...AmmoList$1]; else if (category == "armor") itemList = [...ArmorList$1]; else if (category == "equipment") itemList = [...EquipmentList];
	let selectedItem = itemList[0];
	const dispatch = createEventDispatcher();

	const handleKeydown = e => {
		if (e.key === "Escape") dispatch("close");
	};

	const previouslyFocused = typeof document !== "undefined" && document.activeElement;
	if (previouslyFocused) onDestroy(_ => previouslyFocused.focus());

	const add = () => {
		if (category == "ammo") $$invalidate(1, selectedItem.qty = 0, selectedItem);
		$character.gear[category].inventory.push(selectedItem);
		character.set($character);
		dispatch("close");
	};

	const writable_props = ["category"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AddItemModal> was created with unknown prop '${key}'`);
	});

	const click_handler = () => dispatch("close");

	function select_change_handler() {
		selectedItem = select_value(this);
		$$invalidate(1, selectedItem);
		$$invalidate(0, itemList);
	}

	const click_handler_1 = () => add();
	const click_handler_2 = () => dispatch("close");

	$$self.$$set = $$props => {
		if ("category" in $$props) $$invalidate(5, category = $$props.category);
	};

	$$self.$capture_state = () => ({
		AmmoList: AmmoList$1,
		ArmorList: ArmorList$1,
		EquipmentList,
		MeleeList: MeleeWeaponList$1,
		RangedList: RangedWeaponList$1,
		character,
		createEventDispatcher,
		onDestroy,
		category,
		itemList,
		selectedItem,
		dispatch,
		handleKeydown,
		previouslyFocused,
		add,
		$character
	});

	$$self.$inject_state = $$props => {
		if ("category" in $$props) $$invalidate(5, category = $$props.category);
		if ("itemList" in $$props) $$invalidate(0, itemList = $$props.itemList);
		if ("selectedItem" in $$props) $$invalidate(1, selectedItem = $$props.selectedItem);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		itemList,
		selectedItem,
		dispatch,
		handleKeydown,
		add,
		category,
		click_handler,
		select_change_handler,
		click_handler_1,
		click_handler_2
	];
}

class AddItemModal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { category: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AddItemModal",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*category*/ ctx[5] === undefined && !("category" in props)) {
			console.warn("<AddItemModal> was created without expected prop 'category'");
		}
	}

	get category() {
		throw new Error("<AddItemModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set category(value) {
		throw new Error("<AddItemModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Capitalize = (string) => {
	return string
		.split(' ')
		.map(word => word.charAt(0).toUpperCase() + word.substring(1))
		.join(' ')
};

/* src/components/views/character/GearItem.svelte generated by Svelte v3.29.0 */
const file$4 = "src/components/views/character/GearItem.svelte";

// (16:1) {#if mode != 'readonly'}
function create_if_block$1(ctx) {
	let div1;
	let button;
	let div0;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div1 = element("div");
			button = element("button");
			div0 = element("div");
			t = text("");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			button = claim_element(div1_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			div0 = claim_element(button_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t = claim_text(div0_nodes, "");
			div0_nodes.forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "btn-icon");
			add_location(div0, file$4, 18, 4, 488);
			attr_dev(button, "class", "btn-box trash-btn");
			add_location(button, file$4, 17, 3, 405);
			attr_dev(div1, "class", "trash svelte-1k79j59");
			add_location(div1, file$4, 16, 2, 382);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, button);
			append_dev(button, div0);
			append_dev(div0, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(16:1) {#if mode != 'readonly'}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div;
	let gearblock;
	let t;
	let current;

	gearblock = new GearBlock({
			props: {
				item: /*item*/ ctx[2],
				mode: /*mode*/ ctx[0]
			},
			$$inline: true
		});

	let if_block = /*mode*/ ctx[0] != "readonly" && create_if_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			create_component(gearblock.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(gearblock.$$.fragment, div_nodes);
			t = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "gear-item svelte-1k79j59");
			add_location(div, file$4, 13, 0, 301);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(gearblock, div, null);
			append_dev(div, t);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const gearblock_changes = {};
			if (dirty & /*item*/ 4) gearblock_changes.item = /*item*/ ctx[2];
			if (dirty & /*mode*/ 1) gearblock_changes.mode = /*mode*/ ctx[0];
			gearblock.$set(gearblock_changes);

			if (/*mode*/ ctx[0] != "readonly") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gearblock.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(gearblock.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(gearblock);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(6, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GearItem", slots, []);

	let { mode } = $$props,
		{ category } = $$props,
		{ item } = $$props,
		{ index } = $$props;

	const trashItem = (category, index = 0) => {
		$character.gear[category].inventory.splice(index, 1);
		character.set($character);
	};

	const writable_props = ["mode", "category", "item", "index"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GearItem> was created with unknown prop '${key}'`);
	});

	const click_handler = () => trashItem(category, index);

	$$self.$$set = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
		if ("category" in $$props) $$invalidate(1, category = $$props.category);
		if ("item" in $$props) $$invalidate(2, item = $$props.item);
		if ("index" in $$props) $$invalidate(3, index = $$props.index);
	};

	$$self.$capture_state = () => ({
		GearBlock,
		character,
		mode,
		category,
		item,
		index,
		trashItem,
		$character
	});

	$$self.$inject_state = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
		if ("category" in $$props) $$invalidate(1, category = $$props.category);
		if ("item" in $$props) $$invalidate(2, item = $$props.item);
		if ("index" in $$props) $$invalidate(3, index = $$props.index);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [mode, category, item, index, trashItem, click_handler];
}

class GearItem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { mode: 0, category: 1, item: 2, index: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GearItem",
			options,
			id: create_fragment$4.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*mode*/ ctx[0] === undefined && !("mode" in props)) {
			console.warn("<GearItem> was created without expected prop 'mode'");
		}

		if (/*category*/ ctx[1] === undefined && !("category" in props)) {
			console.warn("<GearItem> was created without expected prop 'category'");
		}

		if (/*item*/ ctx[2] === undefined && !("item" in props)) {
			console.warn("<GearItem> was created without expected prop 'item'");
		}

		if (/*index*/ ctx[3] === undefined && !("index" in props)) {
			console.warn("<GearItem> was created without expected prop 'index'");
		}
	}

	get mode() {
		throw new Error("<GearItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<GearItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get category() {
		throw new Error("<GearItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set category(value) {
		throw new Error("<GearItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get item() {
		throw new Error("<GearItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set item(value) {
		throw new Error("<GearItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get index() {
		throw new Error("<GearItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set index(value) {
		throw new Error("<GearItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/views/character/GearCategory.svelte generated by Svelte v3.29.0 */
const file$5 = "src/components/views/character/GearCategory.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	child_ctx[7] = i;
	return child_ctx;
}

// (19:3) {#each $character.gear[category].inventory as item, index}
function create_each_block$2(ctx) {
	let gearitem;
	let current;

	gearitem = new GearItem({
			props: {
				mode: /*mode*/ ctx[0],
				category: /*category*/ ctx[1],
				item: /*item*/ ctx[5],
				index: /*index*/ ctx[7]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(gearitem.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(gearitem.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(gearitem, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gearitem_changes = {};
			if (dirty & /*mode*/ 1) gearitem_changes.mode = /*mode*/ ctx[0];
			if (dirty & /*category*/ 2) gearitem_changes.category = /*category*/ ctx[1];
			if (dirty & /*$character, category*/ 10) gearitem_changes.item = /*item*/ ctx[5];
			gearitem.$set(gearitem_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gearitem.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(gearitem.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(gearitem, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(19:3) {#each $character.gear[category].inventory as item, index}",
		ctx
	});

	return block;
}

// (23:2) {#if mode != 'readonly'}
function create_if_block$2(ctx) {
	let div1;
	let button;
	let div0;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block = /*modalVisible*/ ctx[2] && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			button = element("button");
			div0 = element("div");
			t0 = text("");
			t1 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			button = claim_element(div1_nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			div0 = claim_element(button_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, "");
			div0_nodes.forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "btn-icon");
			add_location(div0, file$5, 25, 5, 766);
			attr_dev(button, "class", "btn-box add-btn");
			add_location(button, file$5, 24, 4, 698);
			attr_dev(div1, "class", "add-section");
			add_location(div1, file$5, 23, 3, 668);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, button);
			append_dev(button, div0);
			append_dev(div0, t0);
			append_dev(div1, t1);
			if (if_block) if_block.m(div1, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*toggleAddItemModal*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*modalVisible*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*modalVisible*/ 4) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(23:2) {#if mode != 'readonly'}",
		ctx
	});

	return block;
}

// (28:4) {#if modalVisible}
function create_if_block_1$1(ctx) {
	let additemmodal;
	let current;

	additemmodal = new AddItemModal({
			props: { category: /*category*/ ctx[1] },
			$$inline: true
		});

	additemmodal.$on("close", /*toggleAddItemModal*/ ctx[4]);

	const block = {
		c: function create() {
			create_component(additemmodal.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(additemmodal.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(additemmodal, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const additemmodal_changes = {};
			if (dirty & /*category*/ 2) additemmodal_changes.category = /*category*/ ctx[1];
			additemmodal.$set(additemmodal_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(additemmodal.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(additemmodal.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(additemmodal, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(28:4) {#if modalVisible}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let details;
	let summary;
	let t0_value = Capitalize(/*category*/ ctx[1]) + "";
	let t0;
	let t1;
	let div1;
	let div0;
	let t2;
	let current;
	let each_value = /*$character*/ ctx[3].gear[/*category*/ ctx[1]].inventory;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block = /*mode*/ ctx[0] != "readonly" && create_if_block$2(ctx);

	const block = {
		c: function create() {
			details = element("details");
			summary = element("summary");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			details = claim_element(nodes, "DETAILS", { class: true, close: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", {});
			var summary_nodes = children(summary);
			t0 = claim_text(summary_nodes, t0_value);
			summary_nodes.forEach(detach_dev);
			t1 = claim_space(details_nodes);
			div1 = claim_element(details_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			t2 = claim_space(div1_nodes);
			if (if_block) if_block.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			details_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(summary, file$5, 15, 1, 399);
			attr_dev(div0, "class", "gear-item-list");
			add_location(div0, file$5, 17, 2, 477);
			attr_dev(div1, "class", "gear-category-card svelte-14kbeq3");
			add_location(div1, file$5, 16, 1, 442);
			attr_dev(details, "class", "gear-category svelte-14kbeq3");
			attr_dev(details, "close", "");
			add_location(details, file$5, 14, 0, 360);
		},
		m: function mount(target, anchor) {
			insert_dev(target, details, anchor);
			append_dev(details, summary);
			append_dev(summary, t0);
			append_dev(details, t1);
			append_dev(details, div1);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			append_dev(div1, t2);
			if (if_block) if_block.m(div1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*category*/ 2) && t0_value !== (t0_value = Capitalize(/*category*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (dirty & /*mode, category, $character*/ 11) {
				each_value = /*$character*/ ctx[3].gear[/*category*/ ctx[1]].inventory;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div0, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*mode*/ ctx[0] != "readonly") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*mode*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(details);
			destroy_each(each_blocks, detaching);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(3, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("GearCategory", slots, []);
	let { mode } = $$props, { category } = $$props;
	let modalVisible = false;
	const toggleAddItemModal = () => $$invalidate(2, modalVisible = !modalVisible);
	const writable_props = ["mode", "category"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GearCategory> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
		if ("category" in $$props) $$invalidate(1, category = $$props.category);
	};

	$$self.$capture_state = () => ({
		AddItemModal,
		Capitalize,
		GearItem,
		character,
		mode,
		category,
		modalVisible,
		toggleAddItemModal,
		$character
	});

	$$self.$inject_state = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
		if ("category" in $$props) $$invalidate(1, category = $$props.category);
		if ("modalVisible" in $$props) $$invalidate(2, modalVisible = $$props.modalVisible);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [mode, category, modalVisible, $character, toggleAddItemModal];
}

class GearCategory extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { mode: 0, category: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GearCategory",
			options,
			id: create_fragment$5.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*mode*/ ctx[0] === undefined && !("mode" in props)) {
			console.warn("<GearCategory> was created without expected prop 'mode'");
		}

		if (/*category*/ ctx[1] === undefined && !("category" in props)) {
			console.warn("<GearCategory> was created without expected prop 'category'");
		}
	}

	get mode() {
		throw new Error("<GearCategory>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<GearCategory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get category() {
		throw new Error("<GearCategory>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set category(value) {
		throw new Error("<GearCategory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/views/character/Gear.svelte generated by Svelte v3.29.0 */
const file$6 = "src/components/views/character/Gear.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (13:3) {#each Gear.categories as category}
function create_each_block$3(ctx) {
	let gearcategory;
	let current;

	gearcategory = new GearCategory({
			props: {
				mode: /*mode*/ ctx[0],
				category: /*category*/ ctx[1]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(gearcategory.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(gearcategory.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(gearcategory, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const gearcategory_changes = {};
			if (dirty & /*mode*/ 1) gearcategory_changes.mode = /*mode*/ ctx[0];
			gearcategory.$set(gearcategory_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(gearcategory.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(gearcategory.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(gearcategory, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(13:3) {#each Gear.categories as category}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let details;
	let summary;
	let t0;
	let t1;
	let div1;
	let div0;
	let current;
	let each_value = GearList.categories;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			details = element("details");
			summary = element("summary");
			t0 = text("Gear");
			t1 = space();
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			details = claim_element(nodes, "DETAILS", { class: true, close: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", { class: true });
			var summary_nodes = children(summary);
			t0 = claim_text(summary_nodes, "Gear");
			summary_nodes.forEach(detach_dev);
			t1 = claim_space(details_nodes);
			div1 = claim_element(details_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			details_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(summary, "class", "sheet-card-title");
			add_location(summary, file$6, 9, 1, 184);
			attr_dev(div0, "class", "gear-category-list");
			add_location(div0, file$6, 11, 2, 261);
			attr_dev(div1, "class", "sheet-card");
			add_location(div1, file$6, 10, 1, 234);
			attr_dev(details, "class", "sheet-details");
			attr_dev(details, "close", "");
			add_location(details, file$6, 8, 0, 145);
		},
		m: function mount(target, anchor) {
			insert_dev(target, details, anchor);
			append_dev(details, summary);
			append_dev(summary, t0);
			append_dev(details, t1);
			append_dev(details, div1);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*mode, Gear*/ 1) {
				each_value = GearList.categories;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div0, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(details);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Gear", slots, []);
	let { mode = "readonly" } = $$props;
	const writable_props = ["mode"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Gear> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	$$self.$capture_state = () => ({ Gear: GearList, GearCategory, mode });

	$$self.$inject_state = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [mode];
}

class Gear_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { mode: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Gear_1",
			options,
			id: create_fragment$6.name
		});
	}

	get mode() {
		throw new Error("<Gear>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<Gear>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/views/character/BodyParts.svelte generated by Svelte v3.29.0 */

const file$7 = "src/components/views/character/BodyParts.svelte";

// (15:4) {:else}
function create_else_block_5(ctx) {
	let input;
	let input_min_value;
	let input_max_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				min: true,
				max: true,
				class: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "number");
			attr_dev(input, "min", input_min_value = "-" + /*$character*/ ctx[2].health.head.score);
			attr_dev(input, "max", input_max_value = /*$character*/ ctx[2].health.head.score);
			attr_dev(input, "class", "svelte-eczy0o");
			add_location(input, file$7, 15, 5, 329);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[2].health.head.current);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[3]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && input_min_value !== (input_min_value = "-" + /*$character*/ ctx[2].health.head.score)) {
				attr_dev(input, "min", input_min_value);
			}

			if (dirty & /*$character*/ 4 && input_max_value !== (input_max_value = /*$character*/ ctx[2].health.head.score)) {
				attr_dev(input, "max", input_max_value);
			}

			if (dirty & /*$character*/ 4 && to_number(input.value) !== /*$character*/ ctx[2].health.head.current) {
				set_input_value(input, /*$character*/ ctx[2].health.head.current);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_5.name,
		type: "else",
		source: "(15:4) {:else}",
		ctx
	});

	return block;
}

// (13:4) {#if mode == 'readonly'}
function create_if_block_5$1(ctx) {
	let t_value = /*$character*/ ctx[2].health.head.score + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && t_value !== (t_value = /*$character*/ ctx[2].health.head.score + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$1.name,
		type: "if",
		source: "(13:4) {#if mode == 'readonly'}",
		ctx
	});

	return block;
}

// (31:4) {:else}
function create_else_block_4(ctx) {
	let input;
	let input_min_value;
	let input_max_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				min: true,
				max: true,
				class: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "number");
			attr_dev(input, "min", input_min_value = "-" + /*$character*/ ctx[2].health.leftArm.score);
			attr_dev(input, "max", input_max_value = /*$character*/ ctx[2].health.leftArm.score);
			attr_dev(input, "class", "svelte-eczy0o");
			add_location(input, file$7, 31, 5, 789);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[2].health.leftArm.current);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[4]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && input_min_value !== (input_min_value = "-" + /*$character*/ ctx[2].health.leftArm.score)) {
				attr_dev(input, "min", input_min_value);
			}

			if (dirty & /*$character*/ 4 && input_max_value !== (input_max_value = /*$character*/ ctx[2].health.leftArm.score)) {
				attr_dev(input, "max", input_max_value);
			}

			if (dirty & /*$character*/ 4 && to_number(input.value) !== /*$character*/ ctx[2].health.leftArm.current) {
				set_input_value(input, /*$character*/ ctx[2].health.leftArm.current);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_4.name,
		type: "else",
		source: "(31:4) {:else}",
		ctx
	});

	return block;
}

// (29:4) {#if mode == 'readonly'}
function create_if_block_4$1(ctx) {
	let t_value = /*$character*/ ctx[2].health.leftArm.score + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && t_value !== (t_value = /*$character*/ ctx[2].health.leftArm.score + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(29:4) {#if mode == 'readonly'}",
		ctx
	});

	return block;
}

// (47:4) {:else}
function create_else_block_3(ctx) {
	let input;
	let input_min_value;
	let input_max_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				min: true,
				max: true,
				class: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "number");
			attr_dev(input, "min", input_min_value = "-" + /*$character*/ ctx[2].health.leftLeg.score);
			attr_dev(input, "max", input_max_value = /*$character*/ ctx[2].health.leftLeg.score);
			attr_dev(input, "class", "svelte-eczy0o");
			add_location(input, file$7, 47, 5, 1261);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[2].health.leftLeg.current);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_2*/ ctx[5]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && input_min_value !== (input_min_value = "-" + /*$character*/ ctx[2].health.leftLeg.score)) {
				attr_dev(input, "min", input_min_value);
			}

			if (dirty & /*$character*/ 4 && input_max_value !== (input_max_value = /*$character*/ ctx[2].health.leftLeg.score)) {
				attr_dev(input, "max", input_max_value);
			}

			if (dirty & /*$character*/ 4 && to_number(input.value) !== /*$character*/ ctx[2].health.leftLeg.current) {
				set_input_value(input, /*$character*/ ctx[2].health.leftLeg.current);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3.name,
		type: "else",
		source: "(47:4) {:else}",
		ctx
	});

	return block;
}

// (45:4) {#if mode == 'readonly'}
function create_if_block_3$1(ctx) {
	let t_value = /*$character*/ ctx[2].health.leftLeg.score + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && t_value !== (t_value = /*$character*/ ctx[2].health.leftLeg.score + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(45:4) {#if mode == 'readonly'}",
		ctx
	});

	return block;
}

// (79:4) {:else}
function create_else_block_2(ctx) {
	let input;
	let input_min_value;
	let input_max_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				min: true,
				max: true,
				class: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "number");
			attr_dev(input, "min", input_min_value = "-" + /*$character*/ ctx[2].health.torso.score);
			attr_dev(input, "max", input_max_value = /*$character*/ ctx[2].health.torso.score);
			attr_dev(input, "class", "svelte-eczy0o");
			add_location(input, file$7, 79, 5, 2147);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[2].health.torso.current);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_3*/ ctx[6]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && input_min_value !== (input_min_value = "-" + /*$character*/ ctx[2].health.torso.score)) {
				attr_dev(input, "min", input_min_value);
			}

			if (dirty & /*$character*/ 4 && input_max_value !== (input_max_value = /*$character*/ ctx[2].health.torso.score)) {
				attr_dev(input, "max", input_max_value);
			}

			if (dirty & /*$character*/ 4 && to_number(input.value) !== /*$character*/ ctx[2].health.torso.current) {
				set_input_value(input, /*$character*/ ctx[2].health.torso.current);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(79:4) {:else}",
		ctx
	});

	return block;
}

// (77:4) {#if mode == 'readonly'}
function create_if_block_2$1(ctx) {
	let t_value = /*$character*/ ctx[2].health.torso.score + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && t_value !== (t_value = /*$character*/ ctx[2].health.torso.score + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(77:4) {#if mode == 'readonly'}",
		ctx
	});

	return block;
}

// (95:4) {:else}
function create_else_block_1(ctx) {
	let input;
	let input_min_value;
	let input_max_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				min: true,
				max: true,
				class: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "number");
			attr_dev(input, "min", input_min_value = "-" + /*$character*/ ctx[2].health.rightArm.score);
			attr_dev(input, "max", input_max_value = /*$character*/ ctx[2].health.rightArm.score);
			attr_dev(input, "class", "svelte-eczy0o");
			add_location(input, file$7, 95, 5, 2614);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[2].health.rightArm.current);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_4*/ ctx[7]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && input_min_value !== (input_min_value = "-" + /*$character*/ ctx[2].health.rightArm.score)) {
				attr_dev(input, "min", input_min_value);
			}

			if (dirty & /*$character*/ 4 && input_max_value !== (input_max_value = /*$character*/ ctx[2].health.rightArm.score)) {
				attr_dev(input, "max", input_max_value);
			}

			if (dirty & /*$character*/ 4 && to_number(input.value) !== /*$character*/ ctx[2].health.rightArm.current) {
				set_input_value(input, /*$character*/ ctx[2].health.rightArm.current);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(95:4) {:else}",
		ctx
	});

	return block;
}

// (93:4) {#if mode == 'readonly'}
function create_if_block_1$2(ctx) {
	let t_value = /*$character*/ ctx[2].health.rightArm.score + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && t_value !== (t_value = /*$character*/ ctx[2].health.rightArm.score + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(93:4) {#if mode == 'readonly'}",
		ctx
	});

	return block;
}

// (111:4) {:else}
function create_else_block(ctx) {
	let input;
	let input_min_value;
	let input_max_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				min: true,
				max: true,
				class: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "number");
			attr_dev(input, "min", input_min_value = "-" + /*$character*/ ctx[2].health.rightLeg.score);
			attr_dev(input, "max", input_max_value = /*$character*/ ctx[2].health.rightLeg.score);
			attr_dev(input, "class", "svelte-eczy0o");
			add_location(input, file$7, 111, 5, 3093);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[2].health.rightLeg.current);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_5*/ ctx[8]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && input_min_value !== (input_min_value = "-" + /*$character*/ ctx[2].health.rightLeg.score)) {
				attr_dev(input, "min", input_min_value);
			}

			if (dirty & /*$character*/ 4 && input_max_value !== (input_max_value = /*$character*/ ctx[2].health.rightLeg.score)) {
				attr_dev(input, "max", input_max_value);
			}

			if (dirty & /*$character*/ 4 && to_number(input.value) !== /*$character*/ ctx[2].health.rightLeg.current) {
				set_input_value(input, /*$character*/ ctx[2].health.rightLeg.current);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(111:4) {:else}",
		ctx
	});

	return block;
}

// (109:4) {#if mode == 'readonly'}
function create_if_block$3(ctx) {
	let t_value = /*$character*/ ctx[2].health.rightLeg.score + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 4 && t_value !== (t_value = /*$character*/ ctx[2].health.rightLeg.score + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(109:4) {#if mode == 'readonly'}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let div30;
	let div9;
	let div2;
	let div0;
	let t0_value = /*$character*/ ctx[2].health.head.name + "";
	let t0;
	let t1;
	let div1;
	let t2;
	let t3_value = /*$character*/ ctx[2].health.head.score + "";
	let t3;
	let t4;
	let div5;
	let div3;
	let t5_value = /*$character*/ ctx[2].health.leftArm.name + "";
	let t5;
	let t6;
	let div4;
	let t7;
	let t8_value = /*$character*/ ctx[2].health.leftArm.score + "";
	let t8;
	let t9;
	let div8;
	let div6;
	let t10_value = /*$character*/ ctx[2].health.leftLeg.name + "";
	let t10;
	let t11;
	let div7;
	let t12;
	let t13_value = /*$character*/ ctx[2].health.leftLeg.score + "";
	let t13;
	let t14;
	let div19;
	let div11;
	let div10;
	let t15;
	let div15;
	let div12;
	let t16;
	let div13;
	let t17;
	let div14;
	let t18;
	let div18;
	let div16;
	let t19;
	let div17;
	let t20;
	let div29;
	let div22;
	let div20;
	let t21_value = /*$character*/ ctx[2].health.torso.name + "";
	let t21;
	let t22;
	let div21;
	let t23;
	let t24_value = /*$character*/ ctx[2].health.torso.score + "";
	let t24;
	let t25;
	let div25;
	let div23;
	let t26_value = /*$character*/ ctx[2].health.rightArm.name + "";
	let t26;
	let t27;
	let div24;
	let t28;
	let t29_value = /*$character*/ ctx[2].health.rightArm.score + "";
	let t29;
	let t30;
	let div28;
	let div26;
	let t31_value = /*$character*/ ctx[2].health.rightLeg.name + "";
	let t31;
	let t32;
	let div27;
	let t33;
	let t34_value = /*$character*/ ctx[2].health.rightLeg.score + "";
	let t34;

	function select_block_type(ctx, dirty) {
		if (/*mode*/ ctx[1] == "readonly") return create_if_block_5$1;
		return create_else_block_5;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*mode*/ ctx[1] == "readonly") return create_if_block_4$1;
		return create_else_block_4;
	}

	let current_block_type_1 = select_block_type_1(ctx);
	let if_block1 = current_block_type_1(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*mode*/ ctx[1] == "readonly") return create_if_block_3$1;
		return create_else_block_3;
	}

	let current_block_type_2 = select_block_type_2(ctx);
	let if_block2 = current_block_type_2(ctx);

	function select_block_type_3(ctx, dirty) {
		if (/*mode*/ ctx[1] == "readonly") return create_if_block_2$1;
		return create_else_block_2;
	}

	let current_block_type_3 = select_block_type_3(ctx);
	let if_block3 = current_block_type_3(ctx);

	function select_block_type_4(ctx, dirty) {
		if (/*mode*/ ctx[1] == "readonly") return create_if_block_1$2;
		return create_else_block_1;
	}

	let current_block_type_4 = select_block_type_4(ctx);
	let if_block4 = current_block_type_4(ctx);

	function select_block_type_5(ctx, dirty) {
		if (/*mode*/ ctx[1] == "readonly") return create_if_block$3;
		return create_else_block;
	}

	let current_block_type_5 = select_block_type_5(ctx);
	let if_block5 = current_block_type_5(ctx);

	const block = {
		c: function create() {
			div30 = element("div");
			div9 = element("div");
			div2 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			div1 = element("div");
			if_block0.c();
			t2 = text(" / ");
			t3 = text(t3_value);
			t4 = space();
			div5 = element("div");
			div3 = element("div");
			t5 = text(t5_value);
			t6 = space();
			div4 = element("div");
			if_block1.c();
			t7 = text(" / ");
			t8 = text(t8_value);
			t9 = space();
			div8 = element("div");
			div6 = element("div");
			t10 = text(t10_value);
			t11 = space();
			div7 = element("div");
			if_block2.c();
			t12 = text(" / ");
			t13 = text(t13_value);
			t14 = space();
			div19 = element("div");
			div11 = element("div");
			div10 = element("div");
			t15 = space();
			div15 = element("div");
			div12 = element("div");
			t16 = space();
			div13 = element("div");
			t17 = space();
			div14 = element("div");
			t18 = space();
			div18 = element("div");
			div16 = element("div");
			t19 = space();
			div17 = element("div");
			t20 = space();
			div29 = element("div");
			div22 = element("div");
			div20 = element("div");
			t21 = text(t21_value);
			t22 = space();
			div21 = element("div");
			if_block3.c();
			t23 = text(" / ");
			t24 = text(t24_value);
			t25 = space();
			div25 = element("div");
			div23 = element("div");
			t26 = text(t26_value);
			t27 = space();
			div24 = element("div");
			if_block4.c();
			t28 = text(" / ");
			t29 = text(t29_value);
			t30 = space();
			div28 = element("div");
			div26 = element("div");
			t31 = text(t31_value);
			t32 = space();
			div27 = element("div");
			if_block5.c();
			t33 = text(" / ");
			t34 = text(t34_value);
			this.h();
		},
		l: function claim(nodes) {
			div30 = claim_element(nodes, "DIV", { class: true });
			var div30_nodes = children(div30);
			div9 = claim_element(div30_nodes, "DIV", { class: true });
			var div9_nodes = children(div9);
			div2 = claim_element(div9_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, t0_value);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if_block0.l(div1_nodes);
			t2 = claim_text(div1_nodes, " / ");
			t3 = claim_text(div1_nodes, t3_value);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t4 = claim_space(div9_nodes);
			div5 = claim_element(div9_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			div3 = claim_element(div5_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			t5 = claim_text(div3_nodes, t5_value);
			div3_nodes.forEach(detach_dev);
			t6 = claim_space(div5_nodes);
			div4 = claim_element(div5_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			if_block1.l(div4_nodes);
			t7 = claim_text(div4_nodes, " / ");
			t8 = claim_text(div4_nodes, t8_value);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			t9 = claim_space(div9_nodes);
			div8 = claim_element(div9_nodes, "DIV", { class: true });
			var div8_nodes = children(div8);
			div6 = claim_element(div8_nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			t10 = claim_text(div6_nodes, t10_value);
			div6_nodes.forEach(detach_dev);
			t11 = claim_space(div8_nodes);
			div7 = claim_element(div8_nodes, "DIV", { class: true });
			var div7_nodes = children(div7);
			if_block2.l(div7_nodes);
			t12 = claim_text(div7_nodes, " / ");
			t13 = claim_text(div7_nodes, t13_value);
			div7_nodes.forEach(detach_dev);
			div8_nodes.forEach(detach_dev);
			div9_nodes.forEach(detach_dev);
			t14 = claim_space(div30_nodes);
			div19 = claim_element(div30_nodes, "DIV", { class: true });
			var div19_nodes = children(div19);
			div11 = claim_element(div19_nodes, "DIV", { class: true });
			var div11_nodes = children(div11);
			div10 = claim_element(div11_nodes, "DIV", { class: true });
			children(div10).forEach(detach_dev);
			div11_nodes.forEach(detach_dev);
			t15 = claim_space(div19_nodes);
			div15 = claim_element(div19_nodes, "DIV", { class: true });
			var div15_nodes = children(div15);
			div12 = claim_element(div15_nodes, "DIV", { class: true });
			children(div12).forEach(detach_dev);
			t16 = claim_space(div15_nodes);
			div13 = claim_element(div15_nodes, "DIV", { class: true });
			children(div13).forEach(detach_dev);
			t17 = claim_space(div15_nodes);
			div14 = claim_element(div15_nodes, "DIV", { class: true });
			children(div14).forEach(detach_dev);
			div15_nodes.forEach(detach_dev);
			t18 = claim_space(div19_nodes);
			div18 = claim_element(div19_nodes, "DIV", { class: true });
			var div18_nodes = children(div18);
			div16 = claim_element(div18_nodes, "DIV", { class: true });
			children(div16).forEach(detach_dev);
			t19 = claim_space(div18_nodes);
			div17 = claim_element(div18_nodes, "DIV", { class: true });
			children(div17).forEach(detach_dev);
			div18_nodes.forEach(detach_dev);
			div19_nodes.forEach(detach_dev);
			t20 = claim_space(div30_nodes);
			div29 = claim_element(div30_nodes, "DIV", { class: true });
			var div29_nodes = children(div29);
			div22 = claim_element(div29_nodes, "DIV", { class: true });
			var div22_nodes = children(div22);
			div20 = claim_element(div22_nodes, "DIV", { class: true });
			var div20_nodes = children(div20);
			t21 = claim_text(div20_nodes, t21_value);
			div20_nodes.forEach(detach_dev);
			t22 = claim_space(div22_nodes);
			div21 = claim_element(div22_nodes, "DIV", { class: true });
			var div21_nodes = children(div21);
			if_block3.l(div21_nodes);
			t23 = claim_text(div21_nodes, " / ");
			t24 = claim_text(div21_nodes, t24_value);
			div21_nodes.forEach(detach_dev);
			div22_nodes.forEach(detach_dev);
			t25 = claim_space(div29_nodes);
			div25 = claim_element(div29_nodes, "DIV", { class: true });
			var div25_nodes = children(div25);
			div23 = claim_element(div25_nodes, "DIV", { class: true });
			var div23_nodes = children(div23);
			t26 = claim_text(div23_nodes, t26_value);
			div23_nodes.forEach(detach_dev);
			t27 = claim_space(div25_nodes);
			div24 = claim_element(div25_nodes, "DIV", { class: true });
			var div24_nodes = children(div24);
			if_block4.l(div24_nodes);
			t28 = claim_text(div24_nodes, " / ");
			t29 = claim_text(div24_nodes, t29_value);
			div24_nodes.forEach(detach_dev);
			div25_nodes.forEach(detach_dev);
			t30 = claim_space(div29_nodes);
			div28 = claim_element(div29_nodes, "DIV", { class: true });
			var div28_nodes = children(div28);
			div26 = claim_element(div28_nodes, "DIV", { class: true });
			var div26_nodes = children(div26);
			t31 = claim_text(div26_nodes, t31_value);
			div26_nodes.forEach(detach_dev);
			t32 = claim_space(div28_nodes);
			div27 = claim_element(div28_nodes, "DIV", { class: true });
			var div27_nodes = children(div27);
			if_block5.l(div27_nodes);
			t33 = claim_text(div27_nodes, " / ");
			t34 = claim_text(div27_nodes, t34_value);
			div27_nodes.forEach(detach_dev);
			div28_nodes.forEach(detach_dev);
			div29_nodes.forEach(detach_dev);
			div30_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "body-part-name");
			add_location(div0, file$7, 8, 3, 139);
			attr_dev(div1, "class", "body-part-numbers svelte-eczy0o");
			add_location(div1, file$7, 11, 3, 215);
			attr_dev(div2, "class", "head-label svelte-eczy0o");
			add_location(div2, file$7, 7, 2, 111);
			attr_dev(div3, "class", "body-part-name");
			add_location(div3, file$7, 24, 3, 593);
			attr_dev(div4, "class", "body-part-numbers svelte-eczy0o");
			add_location(div4, file$7, 27, 3, 672);
			attr_dev(div5, "class", "left-arm-label svelte-eczy0o");
			add_location(div5, file$7, 23, 2, 561);
			attr_dev(div6, "class", "body-part-name");
			add_location(div6, file$7, 40, 3, 1065);
			attr_dev(div7, "class", "body-part-numbers svelte-eczy0o");
			add_location(div7, file$7, 43, 3, 1144);
			attr_dev(div8, "class", "left-leg-label svelte-eczy0o");
			add_location(div8, file$7, 39, 2, 1033);
			attr_dev(div9, "class", "left-column svelte-eczy0o");
			add_location(div9, file$7, 6, 1, 83);
			attr_dev(div10, "class", "head body-part svelte-eczy0o");
			add_location(div10, file$7, 58, 3, 1570);
			attr_dev(div11, "class", "head-level svelte-eczy0o");
			add_location(div11, file$7, 57, 2, 1542);
			attr_dev(div12, "class", "left-arm arm body-part svelte-eczy0o");
			add_location(div12, file$7, 61, 3, 1641);
			attr_dev(div13, "class", "torso body-part svelte-eczy0o");
			add_location(div13, file$7, 62, 3, 1683);
			attr_dev(div14, "class", "right-arm arm body-part svelte-eczy0o");
			add_location(div14, file$7, 63, 3, 1718);
			attr_dev(div15, "class", "torso-level svelte-eczy0o");
			add_location(div15, file$7, 60, 2, 1612);
			attr_dev(div16, "class", "left-leg leg body-part svelte-eczy0o");
			add_location(div16, file$7, 66, 3, 1797);
			attr_dev(div17, "class", "right-leg leg body-part svelte-eczy0o");
			add_location(div17, file$7, 67, 3, 1839);
			attr_dev(div18, "class", "legs-level svelte-eczy0o");
			add_location(div18, file$7, 65, 2, 1769);
			attr_dev(div19, "class", "center-column svelte-eczy0o");
			add_location(div19, file$7, 56, 1, 1512);
			attr_dev(div20, "class", "body-part-name");
			add_location(div20, file$7, 72, 3, 1955);
			attr_dev(div21, "class", "body-part-numbers svelte-eczy0o");
			add_location(div21, file$7, 75, 3, 2032);
			attr_dev(div22, "class", "torso-label svelte-eczy0o");
			add_location(div22, file$7, 71, 2, 1926);
			attr_dev(div23, "class", "body-part-name");
			add_location(div23, file$7, 88, 3, 2416);
			attr_dev(div24, "class", "body-part-numbers svelte-eczy0o");
			add_location(div24, file$7, 91, 3, 2496);
			attr_dev(div25, "class", "right-arm-label svelte-eczy0o");
			add_location(div25, file$7, 87, 2, 2383);
			attr_dev(div26, "class", "body-part-name");
			add_location(div26, file$7, 104, 3, 2895);
			attr_dev(div27, "class", "body-part-numbers svelte-eczy0o");
			add_location(div27, file$7, 107, 3, 2975);
			attr_dev(div28, "class", "right-leg-label svelte-eczy0o");
			add_location(div28, file$7, 103, 2, 2862);
			attr_dev(div29, "class", "right-column svelte-eczy0o");
			add_location(div29, file$7, 70, 1, 1897);
			attr_dev(div30, "class", "body-parts-section svelte-eczy0o");
			add_location(div30, file$7, 5, 0, 49);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div30, anchor);
			append_dev(div30, div9);
			append_dev(div9, div2);
			append_dev(div2, div0);
			append_dev(div0, t0);
			append_dev(div2, t1);
			append_dev(div2, div1);
			if_block0.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, t3);
			append_dev(div9, t4);
			append_dev(div9, div5);
			append_dev(div5, div3);
			append_dev(div3, t5);
			append_dev(div5, t6);
			append_dev(div5, div4);
			if_block1.m(div4, null);
			append_dev(div4, t7);
			append_dev(div4, t8);
			append_dev(div9, t9);
			append_dev(div9, div8);
			append_dev(div8, div6);
			append_dev(div6, t10);
			append_dev(div8, t11);
			append_dev(div8, div7);
			if_block2.m(div7, null);
			append_dev(div7, t12);
			append_dev(div7, t13);
			append_dev(div30, t14);
			append_dev(div30, div19);
			append_dev(div19, div11);
			append_dev(div11, div10);
			append_dev(div19, t15);
			append_dev(div19, div15);
			append_dev(div15, div12);
			append_dev(div15, t16);
			append_dev(div15, div13);
			append_dev(div15, t17);
			append_dev(div15, div14);
			append_dev(div19, t18);
			append_dev(div19, div18);
			append_dev(div18, div16);
			append_dev(div18, t19);
			append_dev(div18, div17);
			append_dev(div30, t20);
			append_dev(div30, div29);
			append_dev(div29, div22);
			append_dev(div22, div20);
			append_dev(div20, t21);
			append_dev(div22, t22);
			append_dev(div22, div21);
			if_block3.m(div21, null);
			append_dev(div21, t23);
			append_dev(div21, t24);
			append_dev(div29, t25);
			append_dev(div29, div25);
			append_dev(div25, div23);
			append_dev(div23, t26);
			append_dev(div25, t27);
			append_dev(div25, div24);
			if_block4.m(div24, null);
			append_dev(div24, t28);
			append_dev(div24, t29);
			append_dev(div29, t30);
			append_dev(div29, div28);
			append_dev(div28, div26);
			append_dev(div26, t31);
			append_dev(div28, t32);
			append_dev(div28, div27);
			if_block5.m(div27, null);
			append_dev(div27, t33);
			append_dev(div27, t34);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$character*/ 4 && t0_value !== (t0_value = /*$character*/ ctx[2].health.head.name + "")) set_data_dev(t0, t0_value);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div1, t2);
				}
			}

			if (dirty & /*$character*/ 4 && t3_value !== (t3_value = /*$character*/ ctx[2].health.head.score + "")) set_data_dev(t3, t3_value);
			if (dirty & /*$character*/ 4 && t5_value !== (t5_value = /*$character*/ ctx[2].health.leftArm.name + "")) set_data_dev(t5, t5_value);

			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div4, t7);
				}
			}

			if (dirty & /*$character*/ 4 && t8_value !== (t8_value = /*$character*/ ctx[2].health.leftArm.score + "")) set_data_dev(t8, t8_value);
			if (dirty & /*$character*/ 4 && t10_value !== (t10_value = /*$character*/ ctx[2].health.leftLeg.name + "")) set_data_dev(t10, t10_value);

			if (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if_block2.d(1);
				if_block2 = current_block_type_2(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(div7, t12);
				}
			}

			if (dirty & /*$character*/ 4 && t13_value !== (t13_value = /*$character*/ ctx[2].health.leftLeg.score + "")) set_data_dev(t13, t13_value);
			if (dirty & /*$character*/ 4 && t21_value !== (t21_value = /*$character*/ ctx[2].health.torso.name + "")) set_data_dev(t21, t21_value);

			if (current_block_type_3 === (current_block_type_3 = select_block_type_3(ctx)) && if_block3) {
				if_block3.p(ctx, dirty);
			} else {
				if_block3.d(1);
				if_block3 = current_block_type_3(ctx);

				if (if_block3) {
					if_block3.c();
					if_block3.m(div21, t23);
				}
			}

			if (dirty & /*$character*/ 4 && t24_value !== (t24_value = /*$character*/ ctx[2].health.torso.score + "")) set_data_dev(t24, t24_value);
			if (dirty & /*$character*/ 4 && t26_value !== (t26_value = /*$character*/ ctx[2].health.rightArm.name + "")) set_data_dev(t26, t26_value);

			if (current_block_type_4 === (current_block_type_4 = select_block_type_4(ctx)) && if_block4) {
				if_block4.p(ctx, dirty);
			} else {
				if_block4.d(1);
				if_block4 = current_block_type_4(ctx);

				if (if_block4) {
					if_block4.c();
					if_block4.m(div24, t28);
				}
			}

			if (dirty & /*$character*/ 4 && t29_value !== (t29_value = /*$character*/ ctx[2].health.rightArm.score + "")) set_data_dev(t29, t29_value);
			if (dirty & /*$character*/ 4 && t31_value !== (t31_value = /*$character*/ ctx[2].health.rightLeg.name + "")) set_data_dev(t31, t31_value);

			if (current_block_type_5 === (current_block_type_5 = select_block_type_5(ctx)) && if_block5) {
				if_block5.p(ctx, dirty);
			} else {
				if_block5.d(1);
				if_block5 = current_block_type_5(ctx);

				if (if_block5) {
					if_block5.c();
					if_block5.m(div27, t33);
				}
			}

			if (dirty & /*$character*/ 4 && t34_value !== (t34_value = /*$character*/ ctx[2].health.rightLeg.score + "")) set_data_dev(t34, t34_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div30);
			if_block0.d();
			if_block1.d();
			if_block2.d();
			if_block3.d();
			if_block4.d();
			if_block5.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let $character,
		$$unsubscribe_character = noop,
		$$subscribe_character = () => ($$unsubscribe_character(), $$unsubscribe_character = subscribe(character, $$value => $$invalidate(2, $character = $$value)), character);

	$$self.$$.on_destroy.push(() => $$unsubscribe_character());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("BodyParts", slots, []);
	let { character } = $$props, { mode } = $$props;
	validate_store(character, "character");
	$$subscribe_character();
	const writable_props = ["character", "mode"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BodyParts> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		$character.health.head.current = to_number(this.value);
		character.set($character);
	}

	function input_input_handler_1() {
		$character.health.leftArm.current = to_number(this.value);
		character.set($character);
	}

	function input_input_handler_2() {
		$character.health.leftLeg.current = to_number(this.value);
		character.set($character);
	}

	function input_input_handler_3() {
		$character.health.torso.current = to_number(this.value);
		character.set($character);
	}

	function input_input_handler_4() {
		$character.health.rightArm.current = to_number(this.value);
		character.set($character);
	}

	function input_input_handler_5() {
		$character.health.rightLeg.current = to_number(this.value);
		character.set($character);
	}

	$$self.$$set = $$props => {
		if ("character" in $$props) $$subscribe_character($$invalidate(0, character = $$props.character));
		if ("mode" in $$props) $$invalidate(1, mode = $$props.mode);
	};

	$$self.$capture_state = () => ({ character, mode, $character });

	$$self.$inject_state = $$props => {
		if ("character" in $$props) $$subscribe_character($$invalidate(0, character = $$props.character));
		if ("mode" in $$props) $$invalidate(1, mode = $$props.mode);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		character,
		mode,
		$character,
		input_input_handler,
		input_input_handler_1,
		input_input_handler_2,
		input_input_handler_3,
		input_input_handler_4,
		input_input_handler_5
	];
}

class BodyParts extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { character: 0, mode: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BodyParts",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*character*/ ctx[0] === undefined && !("character" in props)) {
			console.warn("<BodyParts> was created without expected prop 'character'");
		}

		if (/*mode*/ ctx[1] === undefined && !("mode" in props)) {
			console.warn("<BodyParts> was created without expected prop 'mode'");
		}
	}

	get character() {
		throw new Error("<BodyParts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set character(value) {
		throw new Error("<BodyParts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mode() {
		throw new Error("<BodyParts>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<BodyParts>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/views/character/Health.svelte generated by Svelte v3.29.0 */
const file$8 = "src/components/views/character/Health.svelte";

function create_fragment$8(ctx) {
	let details;
	let summary;
	let t0;
	let t1;
	let div;
	let bodyparts;
	let current;

	bodyparts = new BodyParts({
			props: { character, mode: /*mode*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			details = element("details");
			summary = element("summary");
			t0 = text("Health");
			t1 = space();
			div = element("div");
			create_component(bodyparts.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			details = claim_element(nodes, "DETAILS", { class: true, close: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", { class: true });
			var summary_nodes = children(summary);
			t0 = claim_text(summary_nodes, "Health");
			summary_nodes.forEach(detach_dev);
			t1 = claim_space(details_nodes);
			div = claim_element(details_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(bodyparts.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			details_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(summary, "class", "sheet-card-title");
			add_location(summary, file$8, 9, 1, 176);
			attr_dev(div, "class", "sheet-card");
			add_location(div, file$8, 12, 1, 233);
			attr_dev(details, "class", "sheet-details");
			attr_dev(details, "close", "");
			add_location(details, file$8, 8, 0, 137);
		},
		m: function mount(target, anchor) {
			insert_dev(target, details, anchor);
			append_dev(details, summary);
			append_dev(summary, t0);
			append_dev(details, t1);
			append_dev(details, div);
			mount_component(bodyparts, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const bodyparts_changes = {};
			if (dirty & /*mode*/ 1) bodyparts_changes.mode = /*mode*/ ctx[0];
			bodyparts.$set(bodyparts_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(bodyparts.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(bodyparts.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(details);
			destroy_component(bodyparts);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Health", slots, []);
	let { mode } = $$props;
	const writable_props = ["mode"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Health> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	$$self.$capture_state = () => ({ BodyParts, character, mode });

	$$self.$inject_state = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [mode];
}

class Health extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { mode: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Health",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*mode*/ ctx[0] === undefined && !("mode" in props)) {
			console.warn("<Health> was created without expected prop 'mode'");
		}
	}

	get mode() {
		throw new Error("<Health>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<Health>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var LoadCharacter = (userId) => {
	return fetch(
		`/.netlify/functions/character-read`, {
			method: `POST`,
			body: JSON.stringify(userId)
		}
	)
	.then(res => res.json())
};

/* src/components/views/character/LoadCharacterButton.svelte generated by Svelte v3.29.0 */
const file$9 = "src/components/views/character/LoadCharacterButton.svelte";

function create_fragment$9(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text("Load");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Load");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "small-cntr-btn");
			add_location(button, file$9, 11, 0, 284);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*loadCharacter*/ ctx[0], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let $character;
	let $authUserStore;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(1, $character = $$value));
	validate_store(authUserStore, "authUserStore");
	component_subscribe($$self, authUserStore, $$value => $$invalidate(2, $authUserStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("LoadCharacterButton", slots, []);

	const loadCharacter = () => {
		set_store_value(character, $character = LoadCharacter($authUserStore), $character);
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LoadCharacterButton> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		LoadCharacter,
		authUserStore,
		character,
		loadCharacter,
		$character,
		$authUserStore
	});

	return [loadCharacter];
}

class LoadCharacterButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LoadCharacterButton",
			options,
			id: create_fragment$9.name
		});
	}
}

/* src/components/views/character/Notes.svelte generated by Svelte v3.29.0 */
const file$a = "src/components/views/character/Notes.svelte";

// (15:2) {:else}
function create_else_block$1(ctx) {
	let div;
	let t_value = /*$character*/ ctx[1].meta.notes + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t = claim_text(div_nodes, t_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "sheet-notes-block svelte-56u4ze");
			add_location(div, file$a, 15, 3, 338);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && t_value !== (t_value = /*$character*/ ctx[1].meta.notes + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(15:2) {:else}",
		ctx
	});

	return block;
}

// (13:2) {#if mode == 'edit'}
function create_if_block$4(ctx) {
	let textarea;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			textarea = element("textarea");
			this.h();
		},
		l: function claim(nodes) {
			textarea = claim_element(nodes, "TEXTAREA", { class: true, wrap: true });
			children(textarea).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(textarea, "class", "sheet-notes-block svelte-56u4ze");
			attr_dev(textarea, "wrap", "soft");
			add_location(textarea, file$a, 13, 3, 239);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			set_input_value(textarea, /*$character*/ ctx[1].meta.notes);

			if (!mounted) {
				dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[2]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2) {
				set_input_value(textarea, /*$character*/ ctx[1].meta.notes);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(13:2) {#if mode == 'edit'}",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let details;
	let summary;
	let t0;
	let t1;
	let div;

	function select_block_type(ctx, dirty) {
		if (/*mode*/ ctx[0] == "edit") return create_if_block$4;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			details = element("details");
			summary = element("summary");
			t0 = text("Notes");
			t1 = space();
			div = element("div");
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			details = claim_element(nodes, "DETAILS", { class: true, close: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", { class: true });
			var summary_nodes = children(summary);
			t0 = claim_text(summary_nodes, "Notes");
			summary_nodes.forEach(detach_dev);
			t1 = claim_space(details_nodes);
			div = claim_element(details_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			details_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(summary, "class", "sheet-card-title");
			add_location(summary, file$a, 8, 1, 132);
			attr_dev(div, "class", "sheet-card");
			add_location(div, file$a, 11, 1, 188);
			attr_dev(details, "class", "sheet-details");
			attr_dev(details, "close", "");
			add_location(details, file$a, 7, 0, 93);
		},
		m: function mount(target, anchor) {
			insert_dev(target, details, anchor);
			append_dev(details, summary);
			append_dev(summary, t0);
			append_dev(details, t1);
			append_dev(details, div);
			if_block.m(div, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(details);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(1, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Notes", slots, []);
	let { mode } = $$props;
	const writable_props = ["mode"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Notes> was created with unknown prop '${key}'`);
	});

	function textarea_input_handler() {
		$character.meta.notes = this.value;
		character.set($character);
	}

	$$self.$$set = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	$$self.$capture_state = () => ({ character, mode, $character });

	$$self.$inject_state = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [mode, $character, textarea_input_handler];
}

class Notes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { mode: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Notes",
			options,
			id: create_fragment$a.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*mode*/ ctx[0] === undefined && !("mode" in props)) {
			console.warn("<Notes> was created without expected prop 'mode'");
		}
	}

	get mode() {
		throw new Error("<Notes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<Notes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/components/views/character/Properties.svelte generated by Svelte v3.29.0 */
const file$b = "src/components/views/character/Properties.svelte";

// (32:34) 
function create_if_block_3$2(ctx) {
	let t_value = /*$character*/ ctx[1].props.psyche.current + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && t_value !== (t_value = /*$character*/ ctx[1].props.psyche.current + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(32:34) ",
		ctx
	});

	return block;
}

// (26:5) {#if mode == 'edit'}
function create_if_block_2$2(ctx) {
	let input;
	let input_max_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				class: true,
				min: true,
				max: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "number");
			attr_dev(input, "class", "current-value svelte-1oda2k");
			attr_dev(input, "min", "0");
			attr_dev(input, "max", input_max_value = /*$character*/ ctx[1].props.psyche.score);
			add_location(input, file$b, 26, 6, 779);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].props.psyche.current);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[2]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input_max_value !== (input_max_value = /*$character*/ ctx[1].props.psyche.score)) {
				attr_dev(input, "max", input_max_value);
			}

			if (dirty & /*$character*/ 2 && to_number(input.value) !== /*$character*/ ctx[1].props.psyche.current) {
				set_input_value(input, /*$character*/ ctx[1].props.psyche.current);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(26:5) {#if mode == 'edit'}",
		ctx
	});

	return block;
}

// (58:34) 
function create_if_block_1$3(ctx) {
	let t_value = /*$character*/ ctx[1].props.luck.current + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && t_value !== (t_value = /*$character*/ ctx[1].props.luck.current + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(58:34) ",
		ctx
	});

	return block;
}

// (52:5) {#if mode == 'edit'}
function create_if_block$5(ctx) {
	let input;
	let input_max_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				type: true,
				class: true,
				min: true,
				max: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "type", "number");
			attr_dev(input, "class", "current-value svelte-1oda2k");
			attr_dev(input, "min", "0");
			attr_dev(input, "max", input_max_value = /*$character*/ ctx[1].props.luck.score);
			add_location(input, file$b, 52, 6, 1578);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$character*/ ctx[1].props.luck.current);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[3]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 2 && input_max_value !== (input_max_value = /*$character*/ ctx[1].props.luck.score)) {
				attr_dev(input, "max", input_max_value);
			}

			if (dirty & /*$character*/ 2 && to_number(input.value) !== /*$character*/ ctx[1].props.luck.current) {
				set_input_value(input, /*$character*/ ctx[1].props.luck.current);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(52:5) {#if mode == 'edit'}",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let details;
	let summary;
	let t0;
	let t1;
	let div11;
	let div10;
	let div4;
	let div0;
	let t2_value = /*$character*/ ctx[1].props.speed.name + "";
	let t2;
	let t3;
	let t4_value = /*$character*/ ctx[1].props.speed.score + "";
	let t4;
	let t5;
	let div1;
	let t6_value = /*$character*/ ctx[1].props.carry.name + "";
	let t6;
	let t7;
	let t8_value = /*$character*/ ctx[1].props.carry.current + "";
	let t8;
	let t9;
	let t10_value = /*$character*/ ctx[1].props.carry.score + "";
	let t10;
	let t11;
	let div2;
	let t12;
	let t13_value = /*$character*/ ctx[1].props.experience.remaining + "";
	let t13;
	let t14;
	let t15_value = /*$character*/ ctx[1].props.experience.score + "";
	let t15;
	let t16;
	let div3;
	let t17_value = /*$character*/ ctx[1].props.psyche.name + "";
	let t17;
	let t18;
	let t19;
	let t20_value = /*$character*/ ctx[1].props.psyche.score + "";
	let t20;
	let t21;
	let div9;
	let div5;
	let t22_value = /*$character*/ ctx[1].props.dodge.name + "";
	let t22;
	let t23;
	let t24_value = /*$character*/ ctx[1].props.dodge.score + "";
	let t24;
	let t25;
	let div6;
	let t26_value = /*$character*/ ctx[1].props.block.name + "";
	let t26;
	let t27;
	let t28_value = /*$character*/ ctx[1].props.block.score + "";
	let t28;
	let t29;
	let div7;
	let t30_value = /*$character*/ ctx[1].props.intellect.name + "";
	let t30;
	let t31;
	let t32_value = /*$character*/ ctx[1].props.intellect.score + "";
	let t32;
	let t33;
	let div8;
	let t34_value = /*$character*/ ctx[1].props.luck.name + "";
	let t34;
	let t35;
	let t36;
	let t37_value = /*$character*/ ctx[1].props.luck.score + "";
	let t37;

	function select_block_type(ctx, dirty) {
		if (/*mode*/ ctx[0] == "edit") return create_if_block_2$2;
		if (/*mode*/ ctx[0] == "readonly") return create_if_block_3$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type && current_block_type(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*mode*/ ctx[0] == "edit") return create_if_block$5;
		if (/*mode*/ ctx[0] == "readonly") return create_if_block_1$3;
	}

	let current_block_type_1 = select_block_type_1(ctx);
	let if_block1 = current_block_type_1 && current_block_type_1(ctx);

	const block = {
		c: function create() {
			details = element("details");
			summary = element("summary");
			t0 = text("Properties");
			t1 = space();
			div11 = element("div");
			div10 = element("div");
			div4 = element("div");
			div0 = element("div");
			t2 = text(t2_value);
			t3 = text(": ");
			t4 = text(t4_value);
			t5 = space();
			div1 = element("div");
			t6 = text(t6_value);
			t7 = text(": ");
			t8 = text(t8_value);
			t9 = text(" / ");
			t10 = text(t10_value);
			t11 = space();
			div2 = element("div");
			t12 = text("XP: ");
			t13 = text(t13_value);
			t14 = text(" / ");
			t15 = text(t15_value);
			t16 = space();
			div3 = element("div");
			t17 = text(t17_value);
			t18 = text(": \n\t\t\t\t\t");
			if (if_block0) if_block0.c();
			t19 = text(" / ");
			t20 = text(t20_value);
			t21 = space();
			div9 = element("div");
			div5 = element("div");
			t22 = text(t22_value);
			t23 = text(": \n\t\t\t\t\t");
			t24 = text(t24_value);
			t25 = space();
			div6 = element("div");
			t26 = text(t26_value);
			t27 = text(": \n\t\t\t\t\t");
			t28 = text(t28_value);
			t29 = space();
			div7 = element("div");
			t30 = text(t30_value);
			t31 = text(": \n\t\t\t\t\t");
			t32 = text(t32_value);
			t33 = space();
			div8 = element("div");
			t34 = text(t34_value);
			t35 = text(": \n\t\t\t\t\t");
			if (if_block1) if_block1.c();
			t36 = text(" / ");
			t37 = text(t37_value);
			this.h();
		},
		l: function claim(nodes) {
			details = claim_element(nodes, "DETAILS", { class: true, close: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", { class: true });
			var summary_nodes = children(summary);
			t0 = claim_text(summary_nodes, "Properties");
			summary_nodes.forEach(detach_dev);
			t1 = claim_space(details_nodes);
			div11 = claim_element(details_nodes, "DIV", { class: true });
			var div11_nodes = children(div11);
			div10 = claim_element(div11_nodes, "DIV", { class: true });
			var div10_nodes = children(div10);
			div4 = claim_element(div10_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			div0 = claim_element(div4_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t2 = claim_text(div0_nodes, t2_value);
			t3 = claim_text(div0_nodes, ": ");
			t4 = claim_text(div0_nodes, t4_value);
			div0_nodes.forEach(detach_dev);
			t5 = claim_space(div4_nodes);
			div1 = claim_element(div4_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			t6 = claim_text(div1_nodes, t6_value);
			t7 = claim_text(div1_nodes, ": ");
			t8 = claim_text(div1_nodes, t8_value);
			t9 = claim_text(div1_nodes, " / ");
			t10 = claim_text(div1_nodes, t10_value);
			div1_nodes.forEach(detach_dev);
			t11 = claim_space(div4_nodes);
			div2 = claim_element(div4_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			t12 = claim_text(div2_nodes, "XP: ");
			t13 = claim_text(div2_nodes, t13_value);
			t14 = claim_text(div2_nodes, " / ");
			t15 = claim_text(div2_nodes, t15_value);
			div2_nodes.forEach(detach_dev);
			t16 = claim_space(div4_nodes);
			div3 = claim_element(div4_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			t17 = claim_text(div3_nodes, t17_value);
			t18 = claim_text(div3_nodes, ": \n\t\t\t\t\t");
			if (if_block0) if_block0.l(div3_nodes);
			t19 = claim_text(div3_nodes, " / ");
			t20 = claim_text(div3_nodes, t20_value);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			t21 = claim_space(div10_nodes);
			div9 = claim_element(div10_nodes, "DIV", { class: true });
			var div9_nodes = children(div9);
			div5 = claim_element(div9_nodes, "DIV", { class: true });
			var div5_nodes = children(div5);
			t22 = claim_text(div5_nodes, t22_value);
			t23 = claim_text(div5_nodes, ": \n\t\t\t\t\t");
			t24 = claim_text(div5_nodes, t24_value);
			div5_nodes.forEach(detach_dev);
			t25 = claim_space(div9_nodes);
			div6 = claim_element(div9_nodes, "DIV", { class: true });
			var div6_nodes = children(div6);
			t26 = claim_text(div6_nodes, t26_value);
			t27 = claim_text(div6_nodes, ": \n\t\t\t\t\t");
			t28 = claim_text(div6_nodes, t28_value);
			div6_nodes.forEach(detach_dev);
			t29 = claim_space(div9_nodes);
			div7 = claim_element(div9_nodes, "DIV", { class: true });
			var div7_nodes = children(div7);
			t30 = claim_text(div7_nodes, t30_value);
			t31 = claim_text(div7_nodes, ": \n\t\t\t\t\t");
			t32 = claim_text(div7_nodes, t32_value);
			div7_nodes.forEach(detach_dev);
			t33 = claim_space(div9_nodes);
			div8 = claim_element(div9_nodes, "DIV", { class: true });
			var div8_nodes = children(div8);
			t34 = claim_text(div8_nodes, t34_value);
			t35 = claim_text(div8_nodes, ": \n\t\t\t\t\t");
			if (if_block1) if_block1.l(div8_nodes);
			t36 = claim_text(div8_nodes, " / ");
			t37 = claim_text(div8_nodes, t37_value);
			div8_nodes.forEach(detach_dev);
			div9_nodes.forEach(detach_dev);
			div10_nodes.forEach(detach_dev);
			div11_nodes.forEach(detach_dev);
			details_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(summary, "class", "sheet-card-title");
			add_location(summary, file$b, 8, 1, 132);
			attr_dev(div0, "class", "sheet-card-item");
			add_location(div0, file$b, 14, 4, 288);
			attr_dev(div1, "class", "sheet-card-item");
			add_location(div1, file$b, 17, 4, 400);
			attr_dev(div2, "class", "sheet-card-item");
			add_location(div2, file$b, 20, 4, 547);
			attr_dev(div3, "class", "sheet-card-item");
			add_location(div3, file$b, 23, 4, 679);
			attr_dev(div4, "class", "sheet-card-block");
			add_location(div4, file$b, 13, 3, 253);
			attr_dev(div5, "class", "sheet-card-item");
			add_location(div5, file$b, 37, 4, 1118);
			attr_dev(div6, "class", "sheet-card-item");
			add_location(div6, file$b, 41, 4, 1236);
			attr_dev(div7, "class", "sheet-card-item");
			add_location(div7, file$b, 45, 4, 1354);
			attr_dev(div8, "class", "sheet-card-item");
			add_location(div8, file$b, 49, 4, 1480);
			attr_dev(div9, "class", "sheet-card-block");
			add_location(div9, file$b, 36, 3, 1083);
			attr_dev(div10, "class", "sheet-card-body");
			add_location(div10, file$b, 12, 2, 220);
			attr_dev(div11, "class", "sheet-card");
			add_location(div11, file$b, 11, 1, 193);
			attr_dev(details, "class", "sheet-details");
			attr_dev(details, "close", "");
			add_location(details, file$b, 7, 0, 93);
		},
		m: function mount(target, anchor) {
			insert_dev(target, details, anchor);
			append_dev(details, summary);
			append_dev(summary, t0);
			append_dev(details, t1);
			append_dev(details, div11);
			append_dev(div11, div10);
			append_dev(div10, div4);
			append_dev(div4, div0);
			append_dev(div0, t2);
			append_dev(div0, t3);
			append_dev(div0, t4);
			append_dev(div4, t5);
			append_dev(div4, div1);
			append_dev(div1, t6);
			append_dev(div1, t7);
			append_dev(div1, t8);
			append_dev(div1, t9);
			append_dev(div1, t10);
			append_dev(div4, t11);
			append_dev(div4, div2);
			append_dev(div2, t12);
			append_dev(div2, t13);
			append_dev(div2, t14);
			append_dev(div2, t15);
			append_dev(div4, t16);
			append_dev(div4, div3);
			append_dev(div3, t17);
			append_dev(div3, t18);
			if (if_block0) if_block0.m(div3, null);
			append_dev(div3, t19);
			append_dev(div3, t20);
			append_dev(div10, t21);
			append_dev(div10, div9);
			append_dev(div9, div5);
			append_dev(div5, t22);
			append_dev(div5, t23);
			append_dev(div5, t24);
			append_dev(div9, t25);
			append_dev(div9, div6);
			append_dev(div6, t26);
			append_dev(div6, t27);
			append_dev(div6, t28);
			append_dev(div9, t29);
			append_dev(div9, div7);
			append_dev(div7, t30);
			append_dev(div7, t31);
			append_dev(div7, t32);
			append_dev(div9, t33);
			append_dev(div9, div8);
			append_dev(div8, t34);
			append_dev(div8, t35);
			if (if_block1) if_block1.m(div8, null);
			append_dev(div8, t36);
			append_dev(div8, t37);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$character*/ 2 && t2_value !== (t2_value = /*$character*/ ctx[1].props.speed.name + "")) set_data_dev(t2, t2_value);
			if (dirty & /*$character*/ 2 && t4_value !== (t4_value = /*$character*/ ctx[1].props.speed.score + "")) set_data_dev(t4, t4_value);
			if (dirty & /*$character*/ 2 && t6_value !== (t6_value = /*$character*/ ctx[1].props.carry.name + "")) set_data_dev(t6, t6_value);
			if (dirty & /*$character*/ 2 && t8_value !== (t8_value = /*$character*/ ctx[1].props.carry.current + "")) set_data_dev(t8, t8_value);
			if (dirty & /*$character*/ 2 && t10_value !== (t10_value = /*$character*/ ctx[1].props.carry.score + "")) set_data_dev(t10, t10_value);
			if (dirty & /*$character*/ 2 && t13_value !== (t13_value = /*$character*/ ctx[1].props.experience.remaining + "")) set_data_dev(t13, t13_value);
			if (dirty & /*$character*/ 2 && t15_value !== (t15_value = /*$character*/ ctx[1].props.experience.score + "")) set_data_dev(t15, t15_value);
			if (dirty & /*$character*/ 2 && t17_value !== (t17_value = /*$character*/ ctx[1].props.psyche.name + "")) set_data_dev(t17, t17_value);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if (if_block0) if_block0.d(1);
				if_block0 = current_block_type && current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div3, t19);
				}
			}

			if (dirty & /*$character*/ 2 && t20_value !== (t20_value = /*$character*/ ctx[1].props.psyche.score + "")) set_data_dev(t20, t20_value);
			if (dirty & /*$character*/ 2 && t22_value !== (t22_value = /*$character*/ ctx[1].props.dodge.name + "")) set_data_dev(t22, t22_value);
			if (dirty & /*$character*/ 2 && t24_value !== (t24_value = /*$character*/ ctx[1].props.dodge.score + "")) set_data_dev(t24, t24_value);
			if (dirty & /*$character*/ 2 && t26_value !== (t26_value = /*$character*/ ctx[1].props.block.name + "")) set_data_dev(t26, t26_value);
			if (dirty & /*$character*/ 2 && t28_value !== (t28_value = /*$character*/ ctx[1].props.block.score + "")) set_data_dev(t28, t28_value);
			if (dirty & /*$character*/ 2 && t30_value !== (t30_value = /*$character*/ ctx[1].props.intellect.name + "")) set_data_dev(t30, t30_value);
			if (dirty & /*$character*/ 2 && t32_value !== (t32_value = /*$character*/ ctx[1].props.intellect.score + "")) set_data_dev(t32, t32_value);
			if (dirty & /*$character*/ 2 && t34_value !== (t34_value = /*$character*/ ctx[1].props.luck.name + "")) set_data_dev(t34, t34_value);

			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if (if_block1) if_block1.d(1);
				if_block1 = current_block_type_1 && current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(div8, t36);
				}
			}

			if (dirty & /*$character*/ 2 && t37_value !== (t37_value = /*$character*/ ctx[1].props.luck.score + "")) set_data_dev(t37, t37_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(details);

			if (if_block0) {
				if_block0.d();
			}

			if (if_block1) {
				if_block1.d();
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(1, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Properties", slots, []);
	let { mode } = $$props;
	const writable_props = ["mode"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Properties> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		$character.props.psyche.current = to_number(this.value);
		character.set($character);
	}

	function input_input_handler_1() {
		$character.props.luck.current = to_number(this.value);
		character.set($character);
	}

	$$self.$$set = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	$$self.$capture_state = () => ({ character, mode, $character });

	$$self.$inject_state = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [mode, $character, input_input_handler, input_input_handler_1];
}

class Properties extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, { mode: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Properties",
			options,
			id: create_fragment$b.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*mode*/ ctx[0] === undefined && !("mode" in props)) {
			console.warn("<Properties> was created without expected prop 'mode'");
		}
	}

	get mode() {
		throw new Error("<Properties>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<Properties>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const compressAbilities = (char, c) => {
	char.Ab = c.abilities.map(m => {
		return {
			i: m.id,
			t: m.taken
		}
	});
	return char
};

const compressGear = (char, c, abv, type) => {
	for (const item in c.gear[type].inventory) {
		char[abv].push({
			i: c.gear[type].inventory[item].id,
			q: c.gear[type].inventory[item].qty
		});
	}
	return char
};

var CompressCharacter = (c) => {
	let char = {
		Mi: c.meta.id,
		Mu: c.meta.user,
		Mc: c.meta.created,
		Mm: c.meta.modified,
		Mn: c.meta.notes,
		Cm: c.meta.coordinates.map,
		Cx: c.meta.coordinates.x,
		Cy: c.meta.coordinates.y,
		Sc: c.meta.status.completed,
		So: c.meta.status.open,
		Ss: c.meta.status.step,
		Da: c.desc.age.value,
		Dn: c.desc.name.value,
		Dh: c.desc.hair.value,
		De: c.desc.height.value,
		Ds: c.desc.sex.value,
		Dk: c.desc.skin.value,
		Dw: c.desc.weight.value,
		Ta: c.traits.agility.score,
		Tb: c.traits.brains.score,
		Tc: c.traits.constitution.score,
		Td: c.traits.demeanor.score,
		ac: c.skills.acrobatics.score,
		la: c.skills.larceny.score,
		ra: c.skills.ranged.score,
		st: c.skills.stealth.score,
		md: c.skills.medicine.score,
		pe: c.skills.perception.score,
		sc: c.skills.science.score,
		su: c.skills.survival.score,
		at: c.skills.athletics.score,
		bu: c.skills.build.score,
		dr: c.skills.drive.score,
		me: c.skills.melee.score,
		le: c.skills.leadership.score,
		pr: c.skills.perform.score,
		so: c.skills.socialize.score,
		ta: c.skills.tame.score,
		Pl: c.props.luck.current,
		Pp: c.props.psyche.current,
		hD: c.health.head.current,
		rA: c.health.rightArm.current,
		lA: c.health.leftArm.current,
		tO: c.health.torso.current,
		lL: c.health.leftLeg.current,
		rL: c.health.rightLeg.current,
		Ab: [],
		Ga: [],
		Gm: [],
		Gr: [],
		Go: [],
		Ge: []
	};

	char = compressAbilities(char, c);

	char = compressGear(char, c, 'Ga', 'armor');
	char = compressGear(char, c, 'Gm', 'melee');
	char = compressGear(char, c, 'Gr', 'ranged');
	char = compressGear(char, c, 'Go', 'ammo');
	char = compressGear(char, c, 'Ge', 'equipment');

	return char
};

var SaveCharacter = (character) => {
	return fetch(
		`/.netlify/functions/character-create`, {
			method: `POST`,
			body: JSON.stringify(CompressCharacter(character))
		}
	)
	.then(res => res.json())
};

/* src/components/views/character/SaveCharacterButton.svelte generated by Svelte v3.29.0 */

const { console: console_1 } = globals;
const file$c = "src/components/views/character/SaveCharacterButton.svelte";

function create_fragment$c(ctx) {
	let button;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text("Save");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Save");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "small-cntr-btn");
			add_location(button, file$c, 13, 0, 340);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*createCharacter*/ ctx[0], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let $character;
	let $authUserStore;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(1, $character = $$value));
	validate_store(authUserStore, "authUserStore");
	component_subscribe($$self, authUserStore, $$value => $$invalidate(2, $authUserStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SaveCharacterButton", slots, []);

	const createCharacter = () => {
		$character.finalize($authUserStore.id);
		set_store_value(character, $character = SaveCharacter($character), $character);
		console.log($character);
	};

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<SaveCharacterButton> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		SaveCharacter,
		authUserStore,
		character,
		createCharacter,
		$character,
		$authUserStore
	});

	return [createCharacter];
}

class SaveCharacterButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SaveCharacterButton",
			options,
			id: create_fragment$c.name
		});
	}
}

/* src/components/views/character/Skills.svelte generated by Svelte v3.29.0 */

const { Object: Object_1 } = globals;
const file$d = "src/components/views/character/Skills.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[4] = list[i];
	return child_ctx;
}

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (18:6) {#if trait.name == skill.parent}
function create_if_block$6(ctx) {
	let div;
	let t0_value = /*skill*/ ctx[4].name + "";
	let t0;
	let t1;
	let t2_value = /*skill*/ ctx[4].score + "";
	let t2;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_text(div_nodes, ": ");
			t2 = claim_text(div_nodes, t2_value);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "sheet-card-item");
			add_location(div, file$d, 18, 7, 480);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 1 && t0_value !== (t0_value = /*skill*/ ctx[4].name + "")) set_data_dev(t0, t0_value);
			if (dirty & /*$character*/ 1 && t2_value !== (t2_value = /*skill*/ ctx[4].score + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(18:6) {#if trait.name == skill.parent}",
		ctx
	});

	return block;
}

// (17:5) {#each Object.values($character.skills) as skill}
function create_each_block_1(ctx) {
	let if_block_anchor;
	let if_block = /*trait*/ ctx[1].name == /*skill*/ ctx[4].parent && create_if_block$6(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*trait*/ ctx[1].name == /*skill*/ ctx[4].parent) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(17:5) {#each Object.values($character.skills) as skill}",
		ctx
	});

	return block;
}

// (12:3) {#each Object.values($character.traits) as trait}
function create_each_block$4(ctx) {
	let div1;
	let div0;
	let t0_value = /*trait*/ ctx[1].name + "";
	let t0;
	let t1;
	let t2;
	let each_value_1 = Object.values(/*$character*/ ctx[0].skills);
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t0 = claim_text(div0_nodes, t0_value);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div1_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			t2 = claim_space(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "parent-trait svelte-bm8oqp");
			add_location(div0, file$d, 13, 5, 321);
			attr_dev(div1, "class", "sheet-card-block svelte-bm8oqp");
			add_location(div1, file$d, 12, 4, 285);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t0);
			append_dev(div1, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append_dev(div1, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 1 && t0_value !== (t0_value = /*trait*/ ctx[1].name + "")) set_data_dev(t0, t0_value);

			if (dirty & /*Object, $character*/ 1) {
				each_value_1 = Object.values(/*$character*/ ctx[0].skills);
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, t2);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(12:3) {#each Object.values($character.traits) as trait}",
		ctx
	});

	return block;
}

function create_fragment$d(ctx) {
	let details;
	let summary;
	let t0;
	let t1;
	let div1;
	let div0;
	let each_value = Object.values(/*$character*/ ctx[0].traits);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			details = element("details");
			summary = element("summary");
			t0 = text("Skills");
			t1 = space();
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			details = claim_element(nodes, "DETAILS", { class: true, close: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", { class: true });
			var summary_nodes = children(summary);
			t0 = claim_text(summary_nodes, "Skills");
			summary_nodes.forEach(detach_dev);
			t1 = claim_space(details_nodes);
			div1 = claim_element(details_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			details_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(summary, "class", "sheet-card-title");
			add_location(summary, file$d, 6, 1, 114);
			attr_dev(div0, "class", "sheet-card-body");
			add_location(div0, file$d, 10, 2, 198);
			attr_dev(div1, "class", "sheet-card");
			add_location(div1, file$d, 9, 1, 171);
			attr_dev(details, "class", "sheet-details");
			attr_dev(details, "close", "");
			add_location(details, file$d, 5, 0, 75);
		},
		m: function mount(target, anchor) {
			insert_dev(target, details, anchor);
			append_dev(details, summary);
			append_dev(summary, t0);
			append_dev(details, t1);
			append_dev(details, div1);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*Object, $character*/ 1) {
				each_value = Object.values(/*$character*/ ctx[0].traits);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(details);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(0, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Skills", slots, []);
	const writable_props = [];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Skills> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ character, $character });
	return [$character];
}

class Skills extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Skills",
			options,
			id: create_fragment$d.name
		});
	}
}

/* src/components/views/character/Traits.svelte generated by Svelte v3.29.0 */

const { Object: Object_1$1 } = globals;
const file$e = "src/components/views/character/Traits.svelte";

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (12:3) {#each Object.values($character.traits) as trait}
function create_each_block$5(ctx) {
	let div1;
	let div0;
	let span;
	let t0_value = /*trait*/ ctx[1].name + "";
	let t0;
	let t1;
	let t2_value = /*trait*/ ctx[1].score + "";
	let t2;
	let t3;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			span = element("span");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			span = claim_element(div0_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			t1 = claim_text(span_nodes, ": ");
			t2 = claim_text(span_nodes, t2_value);
			span_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			t3 = claim_space(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "trait-name svelte-o6s5tc");
			add_location(span, file$e, 14, 6, 357);
			attr_dev(div0, "class", "sheet-card-item");
			add_location(div0, file$e, 13, 5, 321);
			attr_dev(div1, "class", "sheet-card-block");
			add_location(div1, file$e, 12, 4, 285);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, span);
			append_dev(span, t0);
			append_dev(span, t1);
			append_dev(span, t2);
			append_dev(div1, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$character*/ 1 && t0_value !== (t0_value = /*trait*/ ctx[1].name + "")) set_data_dev(t0, t0_value);
			if (dirty & /*$character*/ 1 && t2_value !== (t2_value = /*trait*/ ctx[1].score + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$5.name,
		type: "each",
		source: "(12:3) {#each Object.values($character.traits) as trait}",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let details;
	let summary;
	let t0;
	let t1;
	let div1;
	let div0;
	let each_value = Object.values(/*$character*/ ctx[0].traits);
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			details = element("details");
			summary = element("summary");
			t0 = text("Traits");
			t1 = space();
			div1 = element("div");
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			details = claim_element(nodes, "DETAILS", { class: true, close: true });
			var details_nodes = children(details);
			summary = claim_element(details_nodes, "SUMMARY", { class: true });
			var summary_nodes = children(summary);
			t0 = claim_text(summary_nodes, "Traits");
			summary_nodes.forEach(detach_dev);
			t1 = claim_space(details_nodes);
			div1 = claim_element(details_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			details_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(summary, "class", "sheet-card-title");
			add_location(summary, file$e, 6, 1, 114);
			attr_dev(div0, "class", "sheet-card-body");
			add_location(div0, file$e, 10, 2, 198);
			attr_dev(div1, "class", "sheet-card");
			add_location(div1, file$e, 9, 1, 171);
			attr_dev(details, "class", "sheet-details");
			attr_dev(details, "close", "");
			add_location(details, file$e, 5, 0, 75);
		},
		m: function mount(target, anchor) {
			insert_dev(target, details, anchor);
			append_dev(details, summary);
			append_dev(summary, t0);
			append_dev(details, t1);
			append_dev(details, div1);
			append_dev(div1, div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*Object, $character*/ 1) {
				each_value = Object.values(/*$character*/ ctx[0].traits);
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(details);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let $character;
	validate_store(character, "character");
	component_subscribe($$self, character, $$value => $$invalidate(0, $character = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Traits", slots, []);
	const writable_props = [];

	Object_1$1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Traits> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ character, $character });
	return [$character];
}

class Traits extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Traits",
			options,
			id: create_fragment$e.name
		});
	}
}

/* src/components/views/character/CharacterSheet.svelte generated by Svelte v3.29.0 */
const file$f = "src/components/views/character/CharacterSheet.svelte";

function create_fragment$f(ctx) {
	let div0;
	let description;
	let t0;
	let traits;
	let t1;
	let skills;
	let t2;
	let properties;
	let t3;
	let health;
	let t4;
	let abilities;
	let t5;
	let gear;
	let t6;
	let notes;
	let t7;
	let div1;
	let deletecharacterbutton;
	let t8;
	let loadcharacterbutton;
	let t9;
	let savecharacterbutton;
	let current;

	description = new Description({
			props: { mode: /*mode*/ ctx[0] },
			$$inline: true
		});

	traits = new Traits({ $$inline: true });
	skills = new Skills({ $$inline: true });

	properties = new Properties({
			props: { mode: /*mode*/ ctx[0] },
			$$inline: true
		});

	health = new Health({
			props: { mode: /*mode*/ ctx[0] },
			$$inline: true
		});

	abilities = new Abilities({ $$inline: true });

	gear = new Gear_1({
			props: { mode: /*mode*/ ctx[0] },
			$$inline: true
		});

	notes = new Notes({
			props: { mode: /*mode*/ ctx[0] },
			$$inline: true
		});

	deletecharacterbutton = new DeleteCharacterButton({ $$inline: true });
	loadcharacterbutton = new LoadCharacterButton({ $$inline: true });
	savecharacterbutton = new SaveCharacterButton({ $$inline: true });

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(description.$$.fragment);
			t0 = space();
			create_component(traits.$$.fragment);
			t1 = space();
			create_component(skills.$$.fragment);
			t2 = space();
			create_component(properties.$$.fragment);
			t3 = space();
			create_component(health.$$.fragment);
			t4 = space();
			create_component(abilities.$$.fragment);
			t5 = space();
			create_component(gear.$$.fragment);
			t6 = space();
			create_component(notes.$$.fragment);
			t7 = space();
			div1 = element("div");
			create_component(deletecharacterbutton.$$.fragment);
			t8 = space();
			create_component(loadcharacterbutton.$$.fragment);
			t9 = space();
			create_component(savecharacterbutton.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(description.$$.fragment, div0_nodes);
			t0 = claim_space(div0_nodes);
			claim_component(traits.$$.fragment, div0_nodes);
			t1 = claim_space(div0_nodes);
			claim_component(skills.$$.fragment, div0_nodes);
			t2 = claim_space(div0_nodes);
			claim_component(properties.$$.fragment, div0_nodes);
			t3 = claim_space(div0_nodes);
			claim_component(health.$$.fragment, div0_nodes);
			t4 = claim_space(div0_nodes);
			claim_component(abilities.$$.fragment, div0_nodes);
			t5 = claim_space(div0_nodes);
			claim_component(gear.$$.fragment, div0_nodes);
			t6 = claim_space(div0_nodes);
			claim_component(notes.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(deletecharacterbutton.$$.fragment, div1_nodes);
			t8 = claim_space(div1_nodes);
			claim_component(loadcharacterbutton.$$.fragment, div1_nodes);
			t9 = claim_space(div1_nodes);
			claim_component(savecharacterbutton.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "character-sheet svelte-dkz0m");
			add_location(div0, file$f, 17, 0, 557);
			attr_dev(div1, "class", "btn-row");
			add_location(div1, file$f, 27, 0, 734);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			mount_component(description, div0, null);
			append_dev(div0, t0);
			mount_component(traits, div0, null);
			append_dev(div0, t1);
			mount_component(skills, div0, null);
			append_dev(div0, t2);
			mount_component(properties, div0, null);
			append_dev(div0, t3);
			mount_component(health, div0, null);
			append_dev(div0, t4);
			mount_component(abilities, div0, null);
			append_dev(div0, t5);
			mount_component(gear, div0, null);
			append_dev(div0, t6);
			mount_component(notes, div0, null);
			insert_dev(target, t7, anchor);
			insert_dev(target, div1, anchor);
			mount_component(deletecharacterbutton, div1, null);
			append_dev(div1, t8);
			mount_component(loadcharacterbutton, div1, null);
			append_dev(div1, t9);
			mount_component(savecharacterbutton, div1, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const description_changes = {};
			if (dirty & /*mode*/ 1) description_changes.mode = /*mode*/ ctx[0];
			description.$set(description_changes);
			const properties_changes = {};
			if (dirty & /*mode*/ 1) properties_changes.mode = /*mode*/ ctx[0];
			properties.$set(properties_changes);
			const health_changes = {};
			if (dirty & /*mode*/ 1) health_changes.mode = /*mode*/ ctx[0];
			health.$set(health_changes);
			const gear_changes = {};
			if (dirty & /*mode*/ 1) gear_changes.mode = /*mode*/ ctx[0];
			gear.$set(gear_changes);
			const notes_changes = {};
			if (dirty & /*mode*/ 1) notes_changes.mode = /*mode*/ ctx[0];
			notes.$set(notes_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(description.$$.fragment, local);
			transition_in(traits.$$.fragment, local);
			transition_in(skills.$$.fragment, local);
			transition_in(properties.$$.fragment, local);
			transition_in(health.$$.fragment, local);
			transition_in(abilities.$$.fragment, local);
			transition_in(gear.$$.fragment, local);
			transition_in(notes.$$.fragment, local);
			transition_in(deletecharacterbutton.$$.fragment, local);
			transition_in(loadcharacterbutton.$$.fragment, local);
			transition_in(savecharacterbutton.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(description.$$.fragment, local);
			transition_out(traits.$$.fragment, local);
			transition_out(skills.$$.fragment, local);
			transition_out(properties.$$.fragment, local);
			transition_out(health.$$.fragment, local);
			transition_out(abilities.$$.fragment, local);
			transition_out(gear.$$.fragment, local);
			transition_out(notes.$$.fragment, local);
			transition_out(deletecharacterbutton.$$.fragment, local);
			transition_out(loadcharacterbutton.$$.fragment, local);
			transition_out(savecharacterbutton.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(description);
			destroy_component(traits);
			destroy_component(skills);
			destroy_component(properties);
			destroy_component(health);
			destroy_component(abilities);
			destroy_component(gear);
			destroy_component(notes);
			if (detaching) detach_dev(t7);
			if (detaching) detach_dev(div1);
			destroy_component(deletecharacterbutton);
			destroy_component(loadcharacterbutton);
			destroy_component(savecharacterbutton);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("CharacterSheet", slots, []);
	let { mode } = $$props;
	const writable_props = ["mode"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CharacterSheet> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	$$self.$capture_state = () => ({
		Abilities,
		DeleteCharacterButton,
		Description,
		Gear: Gear_1,
		Health,
		LoadCharacterButton,
		Notes,
		Properties,
		SaveCharacterButton,
		Skills,
		Traits,
		mode
	});

	$$self.$inject_state = $$props => {
		if ("mode" in $$props) $$invalidate(0, mode = $$props.mode);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [mode];
}

class CharacterSheet extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { mode: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CharacterSheet",
			options,
			id: create_fragment$f.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*mode*/ ctx[0] === undefined && !("mode" in props)) {
			console.warn("<CharacterSheet> was created without expected prop 'mode'");
		}
	}

	get mode() {
		throw new Error("<CharacterSheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<CharacterSheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { CharacterSheet as C };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hhcmFjdGVyU2hlZXQuN2RhMWRhMTQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2NoYXJhY3Rlci9BYmlsaXRpZXMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvaGVscGVycy9kYXRhYmFzZS9EZWxldGVDaGFyYWN0ZXIuanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9jaGFyYWN0ZXIvRGVsZXRlQ2hhcmFjdGVyQnV0dG9uLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2NoYXJhY3Rlci9EZXNjcmlwdGlvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9ydWxlcy9nZWFyL0dlYXJMaXN0LmpzIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvdmlld3MvY2hhcmFjdGVyL0FkZEl0ZW1Nb2RhbC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9oZWxwZXJzL3V0aWxzL0NhcGl0YWxpemUuanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9jaGFyYWN0ZXIvR2Vhckl0ZW0uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvdmlld3MvY2hhcmFjdGVyL0dlYXJDYXRlZ29yeS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9jaGFyYWN0ZXIvR2Vhci5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9jaGFyYWN0ZXIvQm9keVBhcnRzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2NoYXJhY3Rlci9IZWFsdGguc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvaGVscGVycy9kYXRhYmFzZS9Mb2FkQ2hhcmFjdGVyLmpzIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvdmlld3MvY2hhcmFjdGVyL0xvYWRDaGFyYWN0ZXJCdXR0b24uc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvdmlld3MvY2hhcmFjdGVyL05vdGVzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2NoYXJhY3Rlci9Qcm9wZXJ0aWVzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2hlbHBlcnMvZGF0YWJhc2UvQ29tcHJlc3NDaGFyYWN0ZXIuanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9oZWxwZXJzL2RhdGFiYXNlL1NhdmVDaGFyYWN0ZXIuanMiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9jaGFyYWN0ZXIvU2F2ZUNoYXJhY3RlckJ1dHRvbi5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy92aWV3cy9jaGFyYWN0ZXIvU2tpbGxzLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2NoYXJhY3Rlci9UcmFpdHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvdmlld3MvY2hhcmFjdGVyL0NoYXJhY3RlclNoZWV0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuXHRpbXBvcnQgeyBjaGFyYWN0ZXIgfSBmcm9tICdzdG9yZXMvY2hhcmFjdGVyU3RvcmUuanMnXG48L3NjcmlwdD5cblxuXG48ZGV0YWlscyBjbGFzcz0nc2hlZXQtZGV0YWlscycgY2xvc2U+XG5cdDxzdW1tYXJ5IGNsYXNzPSdzaGVldC1jYXJkLXRpdGxlJz5cblx0XHRBYmlsaXRpZXNcblx0PC9zdW1tYXJ5PlxuXHQ8ZGl2IGNsYXNzPSdzaGVldC1jYXJkJz5cblx0XHQ8ZGl2IGNsYXNzPSdzaGVldC1jYXJkLXRhYmxlJz5cblx0XHRcdDxkaXYgY2xhc3M9J3NoZWV0LWNhcmQtdGFibGUtaGVhZGVyJz5cblx0XHRcdFx0PHNwYW4gY2xhc3M9J3NoZWV0LWl0ZW0tbG9uZy1jb2x1bW4nPk5hbWU8L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPSdzaGVldC1pdGVtLXNob3J0LWNvbHVtbic+WFA8L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPSdzaGVldC1pdGVtLXNob3J0LWNvbHVtbic+TWF4PC9zcGFuPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz0nc2hlZXQtaXRlbS1zaG9ydC1jb2x1bW4nPlRha2VuPC9zcGFuPlxuXHRcdFx0PC9kaXY+XG5cdFx0XHR7I2VhY2ggJGNoYXJhY3Rlci5hYmlsaXRpZXMgYXMgYWJpbGl0eX1cblx0XHRcdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC10YWJsZS1yb3cnPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPSdzaGVldC1pdGVtLWxvbmctY29sdW1uJz5cblx0XHRcdFx0XHRcdHthYmlsaXR5Lm5hbWV9e2FiaWxpdHkub3B0c1swXSA/IGAgKCR7YWJpbGl0eS5vcHRzWzBdLm5hbWV9KWAgOiBgYH1cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9J3NoZWV0LWl0ZW0tc2hvcnQtY29sdW1uJz5cblx0XHRcdFx0XHRcdHthYmlsaXR5LnhwfVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz0nc2hlZXQtaXRlbS1zaG9ydC1jb2x1bW4nPlxuXHRcdFx0XHRcdFx0e2FiaWxpdHkubWF4fVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz0nc2hlZXQtaXRlbS1zaG9ydC1jb2x1bW4nPlxuXHRcdFx0XHRcdFx0e2FiaWxpdHkudGFrZW59XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdHsvZWFjaH1cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2RldGFpbHM+IiwiZXhwb3J0IGRlZmF1bHQgKGNoYXJhY3RlcikgPT4ge1xyXG5cdHJldHVybiBmZXRjaChcclxuXHRcdGAvLm5ldGxpZnkvZnVuY3Rpb25zL2NoYXJhY3Rlci1kZWxldGVgLCB7XHJcblx0XHRcdG1ldGhvZDogYFBPU1RgLFxyXG5cdFx0XHRib2R5OiBKU09OLnN0cmluZ2lmeShjaGFyYWN0ZXIuaWQpXHJcblx0XHR9XHJcblx0KS50aGVuKHJlcyA9PiByZXMuanNvbigpKVxyXG59IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgRGVsZXRlQ2hhcmFjdGVyIGZyb20gJ2RhdGFiYXNlL0RlbGV0ZUNoYXJhY3Rlci5qcydcbiAgICBpbXBvcnQgeyBhdXRoVXNlclN0b3JlIH0gZnJvbSAnc3RvcmVzL25ldGxpZnlTdG9yZS5qcydcblxuICAgIGNvbnN0IGRlbGV0ZUNoYXJhY3RlciA9ICgpID0+IHtcbiAgICAgIERlbGV0ZUNoYXJhY3RlcigkYXV0aFVzZXJTdG9yZS5pZClcbiAgICB9XG48L3NjcmlwdD5cblxuXG48YnV0dG9uXG4gICAgY2xhc3M9J3NtYWxsLWNudHItYnRuJ1xuICAgIG9uOmNsaWNrPXtkZWxldGVDaGFyYWN0ZXJ9PlxuICAgIERlbGV0ZVxuPC9idXR0b24+IiwiPHNjcmlwdD5cblx0aW1wb3J0IHsgY2hhcmFjdGVyIH0gZnJvbSAnc3RvcmVzL2NoYXJhY3RlclN0b3JlLmpzJ1xuXG5cdGV4cG9ydCBsZXQgbW9kZVxuPC9zY3JpcHQ+XG5cblxuPGRldGFpbHMgY2xhc3M9J3NoZWV0LWRldGFpbHMnIGNsb3NlPlxuXHQ8c3VtbWFyeSBjbGFzcz0nc2hlZXQtY2FyZC10aXRsZSc+XG5cdFx0RGVzY3JpcHRpb25cblx0PC9zdW1tYXJ5PlxuXHQ8ZGl2IGNsYXNzPSdzaGVldC1jYXJkJz5cblx0XHQ8ZGl2IGNsYXNzPSduYW1lLWJsb2NrJz5cblx0XHRcdDxzcGFuPkNoYXJhY3Rlcjo8L3NwYW4+IFxuXHRcdFx0eyNpZiBtb2RlID09ICdlZGl0J31cblx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdzaGVldC12YWx1ZS1sb25nJyBiaW5kOnZhbHVlPXskY2hhcmFjdGVyLmRlc2MubmFtZS52YWx1ZX0gLz5cblx0XHRcdHs6ZWxzZSBpZiBtb2RlID09ICdyZWFkb25seSd9XG5cdFx0XHRcdDxpbnB1dCB0eXBlPSd0ZXh0JyBjbGFzcz0nc2hlZXQtdmFsdWUtbG9uZycgYmluZDp2YWx1ZT17JGNoYXJhY3Rlci5kZXNjLm5hbWUudmFsdWV9IHJlYWRvbmx5IC8+XG5cdFx0XHR7L2lmfVxuXHRcdDwvZGl2PlxuXHRcdDxkaXYgY2xhc3M9J3NoZWV0LWNhcmQtYm9keSc+XG5cdFx0XHQ8ZGl2IGNsYXNzPSdzaGVldC1jYXJkLWJsb2NrJz5cblx0XHRcdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1pdGVtJz5cblx0XHRcdFx0XHQ8c3Bhbj5BZ2U6PC9zcGFuPiBcblx0XHRcdFx0XHR7I2lmIG1vZGUgPT0gJ2VkaXQnfVxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdzaGVldC12YWx1ZScgYmluZDp2YWx1ZT17JGNoYXJhY3Rlci5kZXNjLmFnZS52YWx1ZX0gLz5cblx0XHRcdFx0XHR7OmVsc2UgaWYgbW9kZSA9PSAncmVhZG9ubHknfVxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdzaGVldC12YWx1ZScgYmluZDp2YWx1ZT17JGNoYXJhY3Rlci5kZXNjLmFnZS52YWx1ZX0gcmVhZG9ubHkgLz5cblx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1pdGVtJz5cblx0XHRcdFx0XHQ8c3Bhbj5IZWlnaHQ6PC9zcGFuPiBcblx0XHRcdFx0XHR7I2lmIG1vZGUgPT0gJ2VkaXQnfVxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdzaGVldC12YWx1ZScgYmluZDp2YWx1ZT17JGNoYXJhY3Rlci5kZXNjLmhlaWdodC52YWx1ZX0gLz5cblx0XHRcdFx0XHR7OmVsc2UgaWYgbW9kZSA9PSAncmVhZG9ubHknfVxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdzaGVldC12YWx1ZScgYmluZDp2YWx1ZT17JGNoYXJhY3Rlci5kZXNjLmhlaWdodC52YWx1ZX0gcmVhZG9ubHkgLz5cblx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1pdGVtJz5cblx0XHRcdFx0XHQ8c3Bhbj5XZWlnaHQ6PC9zcGFuPiBcblx0XHRcdFx0XHR7I2lmIG1vZGUgPT0gJ2VkaXQnfVxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdzaGVldC12YWx1ZScgYmluZDp2YWx1ZT17JGNoYXJhY3Rlci5kZXNjLndlaWdodC52YWx1ZX0gLz5cblx0XHRcdFx0XHR7OmVsc2UgaWYgbW9kZSA9PSAncmVhZG9ubHknfVxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdzaGVldC12YWx1ZScgYmluZDp2YWx1ZT17JGNoYXJhY3Rlci5kZXNjLndlaWdodC52YWx1ZX0gcmVhZG9ubHkgLz5cblx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1ibG9jayc+XG5cdFx0XHRcdDxkaXYgY2xhc3M9J3NoZWV0LWNhcmQtaXRlbSc+XG5cdFx0XHRcdFx0PHNwYW4+U2V4Ojwvc3Bhbj5cblx0XHRcdFx0XHR7I2lmIG1vZGUgPT0gJ2VkaXQnfVxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdzaGVldC12YWx1ZScgYmluZDp2YWx1ZT17JGNoYXJhY3Rlci5kZXNjLnNleC52YWx1ZX0gLz5cblx0XHRcdFx0XHR7OmVsc2UgaWYgbW9kZSA9PSAncmVhZG9ubHknfVxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdzaGVldC12YWx1ZScgYmluZDp2YWx1ZT17JGNoYXJhY3Rlci5kZXNjLnNleC52YWx1ZX0gcmVhZG9ubHkgLz5cblx0XHRcdFx0XHR7L2lmfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1pdGVtJz5cblx0XHRcdFx0XHQ8c3Bhbj5Ta2luOjwvc3Bhbj5cblx0XHRcdFx0XHR7I2lmIG1vZGUgPT0gJ2VkaXQnfVxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdzaGVldC12YWx1ZScgYmluZDp2YWx1ZT17JGNoYXJhY3Rlci5kZXNjLnNraW4udmFsdWV9IC8+XG5cdFx0XHRcdFx0ezplbHNlIGlmIG1vZGUgPT0gJ3JlYWRvbmx5J31cblx0XHRcdFx0XHRcdDxpbnB1dCB0eXBlPSd0ZXh0JyBjbGFzcz0nc2hlZXQtdmFsdWUnIGJpbmQ6dmFsdWU9eyRjaGFyYWN0ZXIuZGVzYy5za2luLnZhbHVlfSByZWFkb25seSAvPlxuXHRcdFx0XHRcdHsvaWZ9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPSdzaGVldC1jYXJkLWl0ZW0nPlxuXHRcdFx0XHRcdDxzcGFuPkhhaXI6PC9zcGFuPlxuXHRcdFx0XHRcdHsjaWYgbW9kZSA9PSAnZWRpdCd9XG5cdFx0XHRcdFx0XHQ8aW5wdXQgdHlwZT0ndGV4dCcgY2xhc3M9J3NoZWV0LXZhbHVlJyBiaW5kOnZhbHVlPXskY2hhcmFjdGVyLmRlc2MuaGFpci52YWx1ZX0gLz5cblx0XHRcdFx0XHR7OmVsc2UgaWYgbW9kZSA9PSAncmVhZG9ubHknfVxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9J3RleHQnIGNsYXNzPSdzaGVldC12YWx1ZScgYmluZDp2YWx1ZT17JGNoYXJhY3Rlci5kZXNjLmhhaXIudmFsdWV9IHJlYWRvbmx5IC8+XG5cdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2RldGFpbHM+XG5cblxuPHN0eWxlPlxuXHQubmFtZS1ibG9jayB7XG5cdFx0YWxpZ24taXRlbXM6IGNlbnRlcjtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdG1hcmdpbi1ib3R0b206IHZhcigtLXMxMDApO1xuXHRcdHBhZGRpbmctYm90dG9tOiAwO1xuXHR9XG5cdC5zaGVldC1jYXJkLWl0ZW0ge1xuXHRcdG1hcmdpbi1ib3R0b206IHZhcigtLXM1MCk7XG5cdFx0dGV4dC1hbGlnbjogcmlnaHQ7XG5cdH1cblx0LnNoZWV0LXZhbHVlLWxvbmcge1xuXHRcdHdpZHRoOiAxMDAlO1xuXHR9XG5cdC5zaGVldC12YWx1ZSB7XG5cdFx0d2lkdGg6IDQ1JTtcblx0fVxuPC9zdHlsZT4iLCJpbXBvcnQgQWNjZXNzb3J5TGlzdCBmcm9tICcuL3dlYXBvbnMvYWNjZXNzb3JpZXMvQWNjZXNzb3J5TGlzdCdcbmltcG9ydCBBbW1vTGlzdCBmcm9tICcuL3dlYXBvbnMvYW1tby9BbW1vTGlzdCdcbmltcG9ydCBBcm1vckxpc3QgZnJvbSAnLi9hcm1vci9Bcm1vckxpc3QnXG5pbXBvcnQgQm9tYkxpc3QgZnJvbSAnLi93ZWFwb25zL2JvbWJzL0JvbWJMaXN0J1xuaW1wb3J0IERvY3VtZW50TGlzdCBmcm9tICcuL2VxdWlwbWVudC9kb2N1bWVudHMvRG9jdW1lbnRMaXN0J1xuaW1wb3J0IERydWdzTGlzdCBmcm9tICcuL2VxdWlwbWVudC9kcnVncy9EcnVnc0xpc3QnXG5pbXBvcnQgRWxlY3Ryb25pY3NMaXN0IGZyb20gJy4vZXF1aXBtZW50L2VsZWN0cm9uaWNzL0VsZWN0cm9uaWNzTGlzdCdcbmltcG9ydCBFcXVpcG1lbnRMaXN0IGZyb20gJy4vZXF1aXBtZW50L21pc2MvTWlzY0xpc3QnXG5pbXBvcnQgTWVkaWNhbExpc3QgZnJvbSAnLi9lcXVpcG1lbnQvbWVkaWNhbC9NZWRpY2FsTGlzdCdcbmltcG9ydCBNZWxlZVdlYXBvbkxpc3QgZnJvbSAnLi93ZWFwb25zL21lbGVlL01lbGVlV2VhcG9uTGlzdCdcbmltcG9ydCBSYW5nZWRXZWFwb25MaXN0IGZyb20gJy4vd2VhcG9ucy9yYW5nZWQvUmFuZ2VkV2VhcG9uTGlzdCdcbmltcG9ydCBTdG9yYWdlTGlzdCBmcm9tICcuL2VxdWlwbWVudC9zdG9yYWdlL1N0b3JhZ2VMaXN0J1xuLy8gaW1wb3J0IFZlaGljbGVMaXN0IGZyb20gJy4vZ2Vhci9WZWhpY2xlc0xpc3QnXG5pbXBvcnQgUHJvcFNvcnQgZnJvbSAndXRpbHMvUHJvcFNvcnQuanMnXG5cblxuY29uc3QgR2Vhckxpc3QgPSB7XG5cdG5hbWU6IGBHZWFyYCxcblx0bGlzdDogW1xuXHRcdC4uLkFjY2Vzc29yeUxpc3QsXG5cdFx0Li4uQW1tb0xpc3QsXG5cdFx0Li4uQXJtb3JMaXN0LFxuXHRcdC4uLkJvbWJMaXN0LFxuXHRcdC4uLkRvY3VtZW50TGlzdCxcblx0XHQuLi5EcnVnc0xpc3QsXG5cdFx0Li4uRWxlY3Ryb25pY3NMaXN0LFxuXHRcdC4uLkVxdWlwbWVudExpc3QsXG5cdFx0Li4uTWVkaWNhbExpc3QsXG5cdFx0Li4uTWVsZWVXZWFwb25MaXN0LFxuXHRcdC4uLlJhbmdlZFdlYXBvbkxpc3QsXG5cdFx0Li4uU3RvcmFnZUxpc3QsXG5cdFx0Ly8gLi4uVmVoaWNsZUxpc3QsXG5cdF0uc29ydCgoYSwgYikgPT4gUHJvcFNvcnQoYSwgYiwgYG5hbWVgKSksXG5cdGNhdGVnb3JpZXM6IFtcblx0XHQnbWVsZWUnLFxuXHRcdCdyYW5nZWQnLFxuXHRcdCdhbW1vJyxcblx0XHQnYXJtb3InLFxuXHRcdCdlcXVpcG1lbnQnXG5cdF1cbn1cblxuZXhwb3J0IGRlZmF1bHQgR2Vhckxpc3QiLCI8c2NyaXB0PlxuXHRpbXBvcnQgQW1tb0xpc3QgZnJvbSAncnVsZXMvZ2Vhci93ZWFwb25zL2FtbW8vQW1tb0xpc3QuanMnXG5cdGltcG9ydCBBcm1vckxpc3QgZnJvbSAncnVsZXMvZ2Vhci9hcm1vci9Bcm1vckxpc3QuanMnXG5cdGltcG9ydCBFcXVpcG1lbnRMaXN0IGZyb20gJ3J1bGVzL2dlYXIvZXF1aXBtZW50L0VxdWlwbWVudExpc3QuanMnXG5cdGltcG9ydCBNZWxlZUxpc3QgZnJvbSAncnVsZXMvZ2Vhci93ZWFwb25zL21lbGVlL01lbGVlV2VhcG9uTGlzdC5qcydcblx0aW1wb3J0IFJhbmdlZExpc3QgZnJvbSAncnVsZXMvZ2Vhci93ZWFwb25zL3JhbmdlZC9SYW5nZWRXZWFwb25MaXN0LmpzJ1xuXHRpbXBvcnQgeyBjaGFyYWN0ZXIgfSBmcm9tICdzdG9yZXMvY2hhcmFjdGVyU3RvcmUuanMnXG5cdGltcG9ydCB7IGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgb25EZXN0cm95IH0gZnJvbSAnc3ZlbHRlJ1xuXG5cdGV4cG9ydCBsZXQgY2F0ZWdvcnlcblxuXHRsZXQgaXRlbUxpc3QgPSBbXVxuXG5cdGlmIChjYXRlZ29yeSA9PSAnbWVsZWUnKSBpdGVtTGlzdCA9IFsuLi5NZWxlZUxpc3RdXG5cdGVsc2UgaWYgKGNhdGVnb3J5ID09ICdyYW5nZWQnKSBpdGVtTGlzdCA9IFsuLi5SYW5nZWRMaXN0XVxuXHRlbHNlIGlmIChjYXRlZ29yeSA9PSAnYW1tbycpIGl0ZW1MaXN0ID0gWy4uLkFtbW9MaXN0XVxuXHRlbHNlIGlmIChjYXRlZ29yeSA9PSAnYXJtb3InKSBpdGVtTGlzdCA9IFsuLi5Bcm1vckxpc3RdXG5cdGVsc2UgaWYgKGNhdGVnb3J5ID09ICdlcXVpcG1lbnQnKSBpdGVtTGlzdCA9IFsuLi5FcXVpcG1lbnRMaXN0XVxuXG5cdGxldCBzZWxlY3RlZEl0ZW0gPSBpdGVtTGlzdFswXVxuXG5cdGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKClcblxuXHRjb25zdCBoYW5kbGVLZXlkb3duID0gZSA9PiB7IGlmIChlLmtleSA9PT0gJ0VzY2FwZScpIGRpc3BhdGNoKCdjbG9zZScpIH1cblxuXHRjb25zdCBwcmV2aW91c2x5Rm9jdXNlZCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuXG5cdGlmIChwcmV2aW91c2x5Rm9jdXNlZCkgb25EZXN0cm95KF8gPT4gcHJldmlvdXNseUZvY3VzZWQuZm9jdXMoKSlcblxuXHRjb25zdCBhZGQgPSAoKSA9PiB7XG5cdFx0aWYgKGNhdGVnb3J5ID09ICdhbW1vJykgc2VsZWN0ZWRJdGVtLnF0eSA9IDBcblx0XHQkY2hhcmFjdGVyLmdlYXJbY2F0ZWdvcnldLmludmVudG9yeS5wdXNoKHNlbGVjdGVkSXRlbSlcblx0XHQkY2hhcmFjdGVyID0gJGNoYXJhY3RlclxuXHRcdGRpc3BhdGNoKCdjbG9zZScpXG5cdH1cbjwvc2NyaXB0PlxuXG5cbjxzdmVsdGU6d2luZG93IG9uOmtleWRvd249e2hhbmRsZUtleWRvd259Lz5cbjxkaXYgY2xhc3M9XCJtb2RhbC1iYWNrZ3JvdW5kXCIgb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKCdjbG9zZScpfT48L2Rpdj5cbjxkaXYgY2xhc3M9XCJtb2RhbFwiIHJvbGU9XCJkaWFsb2dcIiBhcmlhLW1vZGFsPVwidHJ1ZVwiPlxuXHQ8ZGl2IGNsYXNzPSdpdGVtLXNlbGVjdGlvbic+XG5cdFx0PHNlbGVjdCBjbGFzcz0naXRlbS1zZWxlY3RvcicgYmluZDp2YWx1ZT17c2VsZWN0ZWRJdGVtfT5cblx0XHRcdHsjZWFjaCBpdGVtTGlzdCBhcyBpdGVtfVxuXHRcdFx0XHQ8b3B0aW9uIHZhbHVlPSd7aXRlbX0nPntpdGVtLm5hbWV9PC9vcHRpb24+XG5cdFx0XHR7L2VhY2h9XG5cdFx0PC9zZWxlY3Q+XG5cdDwvZGl2PlxuXHQ8ZGl2IGNsYXNzPSdidG4tcm93Jz5cblx0XHQ8YnV0dG9uIGNsYXNzPSdzbWFsbC1jbnRyLWJ0bicgb246Y2xpY2s9eygpID0+IGFkZCgpfT5BZGQ8L2J1dHRvbj5cblx0XHQ8YnV0dG9uIGNsYXNzPSdzbWFsbC1jbnRyLWJ0bicgb246Y2xpY2s9eygpID0+IGRpc3BhdGNoKCdjbG9zZScpfT5DbG9zZTwvYnV0dG9uPlxuXHQ8L2Rpdj5cbjwvZGl2PlxuXG5cbjxzdHlsZT5cblx0Lm1vZGFsLWJhY2tncm91bmQge1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDAsMC43KTtcblx0XHRoZWlnaHQ6IDEwMHZoO1xuXHRcdGxlZnQ6IDA7XG5cdFx0cG9zaXRpb246IGZpeGVkO1xuXHRcdHRvcDogMDtcblx0XHR3aWR0aDogMTAwdnc7XG5cdH1cblx0Lm1vZGFsIHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsMCwwLDAuNSk7XG5cdFx0Ym9yZGVyLXJhZGl1czogdmFyKC0tcmFkaXVzKTtcblx0XHRib3JkZXI6IHZhcigtLXMxKSBzb2xpZDtcblx0XHRjb2xvcjogbGltZTtcblx0XHRoZWlnaHQ6IGZpdC1jb250ZW50O1xuXHRcdGxlZnQ6IDUwdnc7XG5cdFx0bWF4LWhlaWdodDogNzV2aDtcblx0XHRvdmVyZmxvdzogc2Nyb2xsO1xuXHRcdHBhZGRpbmc6IHZhcigtLXMyMDApO1xuXHRcdHBvc2l0aW9uOiBmaXhlZDtcblx0XHRzY3JvbGxiYXItd2lkdGg6IG5vbmU7XG5cdFx0dG9wOiA1MHZoO1xuXHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuXHRcdHdpZHRoOiA4MHZ3O1xuXHR9XG5cdC5pdGVtLXNlbGVjdGlvbiB7XG5cdFx0bWFyZ2luLWJvdHRvbTogdmFyKC0tczIwMCk7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHR9XG5cdC5pdGVtLXNlbGVjdG9yIHtcblx0XHR3aWR0aDogNjAlO1xuXHR9XG5cdDo6LXdlYmtpdC1zY3JvbGxiYXIge1xuXHRcdGRpc3BsYXk6IG5vbmU7XG5cdH1cbjwvc3R5bGU+XG4iLCJleHBvcnQgZGVmYXVsdCAoc3RyaW5nKSA9PiB7XG5cdHJldHVybiBzdHJpbmdcblx0XHQuc3BsaXQoJyAnKVxuXHRcdC5tYXAod29yZCA9PiB3b3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgd29yZC5zdWJzdHJpbmcoMSkpXG5cdFx0LmpvaW4oJyAnKVxufSIsIjxzY3JpcHQ+XG5cdGltcG9ydCBHZWFyQmxvY2sgZnJvbSAndmlld3Mvd2lkZ2V0cy9HZWFyQmxvY2suc3ZlbHRlJ1xuXHRpbXBvcnQgeyBjaGFyYWN0ZXIgfSBmcm9tICdzdG9yZXMvY2hhcmFjdGVyU3RvcmUuanMnXG5cblx0ZXhwb3J0IGxldCBtb2RlLCBjYXRlZ29yeSwgaXRlbSwgaW5kZXhcblxuXHRjb25zdCB0cmFzaEl0ZW0gPSAoY2F0ZWdvcnksIGluZGV4PTApID0+IHtcblx0XHQkY2hhcmFjdGVyLmdlYXJbY2F0ZWdvcnldLmludmVudG9yeS5zcGxpY2UoaW5kZXgsIDEpXG5cdFx0JGNoYXJhY3RlciA9ICRjaGFyYWN0ZXJcblx0fVxuPC9zY3JpcHQ+XG5cblxuPGRpdiBjbGFzcz0nZ2Vhci1pdGVtJz5cblx0PEdlYXJCbG9jayB7aXRlbX0ge21vZGV9IC8+XG5cdHsjaWYgbW9kZSAhPSAncmVhZG9ubHknfVxuXHRcdDxkaXYgY2xhc3M9J3RyYXNoJz5cblx0XHRcdDxidXR0b24gY2xhc3M9J2J0bi1ib3ggdHJhc2gtYnRuJyBvbjpjbGljaz17KCkgPT4gdHJhc2hJdGVtKGNhdGVnb3J5LCBpbmRleCl9PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPSdidG4taWNvbic+JiMxMDAwNjs8L2Rpdj5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdDwvZGl2PlxuXHR7L2lmfVxuPC9kaXY+XG5cblxuPHN0eWxlPlxuXHQuZ2Vhci1pdGVtIHtcblx0XHRib3JkZXI6IDFweCBzb2xpZCBsaW1lO1xuXHRcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG5cdFx0bWFyZ2luLWJvdHRvbTogdmFyKC0tczEwMCk7XG5cdFx0cGFkZGluZzogdmFyKC0tczEwMCk7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdH1cblx0LnRyYXNoIHtcblx0XHR0ZXh0LWFsaWduOiByaWdodDtcblx0fVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgQWRkSXRlbU1vZGFsIGZyb20gJ3ZpZXdzL2NoYXJhY3Rlci9BZGRJdGVtTW9kYWwuc3ZlbHRlJ1xuXHRpbXBvcnQgQ2FwaXRhbGl6ZSBmcm9tICd1dGlscy9DYXBpdGFsaXplLmpzJ1xuXHRpbXBvcnQgR2Vhckl0ZW0gZnJvbSAndmlld3MvY2hhcmFjdGVyL0dlYXJJdGVtLnN2ZWx0ZSdcblx0aW1wb3J0IHsgY2hhcmFjdGVyIH0gZnJvbSAnc3RvcmVzL2NoYXJhY3RlclN0b3JlLmpzJ1xuXG5cdGV4cG9ydCBsZXQgbW9kZSwgY2F0ZWdvcnlcblxuXHRsZXQgbW9kYWxWaXNpYmxlID0gZmFsc2VcblxuXHRjb25zdCB0b2dnbGVBZGRJdGVtTW9kYWwgPSAoKSA9PiBtb2RhbFZpc2libGUgPSAhbW9kYWxWaXNpYmxlXG48L3NjcmlwdD5cblxuXG48ZGV0YWlscyBjbGFzcz0nZ2Vhci1jYXRlZ29yeScgY2xvc2U+XG5cdDxzdW1tYXJ5PntDYXBpdGFsaXplKGNhdGVnb3J5KX08L3N1bW1hcnk+XG5cdDxkaXYgY2xhc3M9J2dlYXItY2F0ZWdvcnktY2FyZCc+XG5cdFx0PGRpdiBjbGFzcz0nZ2Vhci1pdGVtLWxpc3QnPlxuXHRcdFx0eyNlYWNoICRjaGFyYWN0ZXIuZ2VhcltjYXRlZ29yeV0uaW52ZW50b3J5IGFzIGl0ZW0sIGluZGV4fVxuXHRcdFx0XHQ8R2Vhckl0ZW0ge21vZGV9IHtjYXRlZ29yeX0ge2l0ZW19IHtpbmRleH0gLz5cblx0XHRcdHsvZWFjaH1cblx0XHQ8L2Rpdj5cblx0XHR7I2lmIG1vZGUgIT0gJ3JlYWRvbmx5J31cblx0XHRcdDxkaXYgY2xhc3M9J2FkZC1zZWN0aW9uJz5cblx0XHRcdFx0PGJ1dHRvbiBjbGFzcz0nYnRuLWJveCBhZGQtYnRuJyBvbjpjbGljaz17dG9nZ2xlQWRkSXRlbU1vZGFsfT5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPSdidG4taWNvbic+JiMxMDAxMDs8L2Rpdj5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHsjaWYgbW9kYWxWaXNpYmxlfVxuXHRcdFx0XHRcdDxBZGRJdGVtTW9kYWwgb246Y2xvc2U9e3RvZ2dsZUFkZEl0ZW1Nb2RhbH0ge2NhdGVnb3J5fSAvPlxuXHRcdFx0XHR7L2lmfVxuXHRcdFx0PC9kaXY+XG5cdFx0ey9pZn1cblx0PC9kaXY+XG48L2RldGFpbHM+XG5cblxuPHN0eWxlPlxuXHQuZ2Vhci1jYXRlZ29yeSB7XG5cdFx0Ym9yZGVyOiAxcHggc29saWQgbGltZTtcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdG1hcmdpbi1ib3R0b206IHZhcigtLXMxMDApO1xuXHR9XG5cdC5nZWFyLWNhdGVnb3J5LWNhcmQge1xuXHRcdG1hcmdpbjogdmFyKC0tczEwMCk7XG5cdH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cblx0aW1wb3J0IEdlYXIgZnJvbSAncnVsZXMvZ2Vhci9HZWFyTGlzdC5qcydcblx0aW1wb3J0IEdlYXJDYXRlZ29yeSBmcm9tICcuL0dlYXJDYXRlZ29yeS5zdmVsdGUnXG5cblx0ZXhwb3J0IGxldCBtb2RlID0gJ3JlYWRvbmx5J1xuPC9zY3JpcHQ+XG5cblxuPGRldGFpbHMgY2xhc3M9J3NoZWV0LWRldGFpbHMnIGNsb3NlPlxuXHQ8c3VtbWFyeSBjbGFzcz0nc2hlZXQtY2FyZC10aXRsZSc+R2Vhcjwvc3VtbWFyeT5cblx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZCc+XG5cdFx0PGRpdiBjbGFzcz0nZ2Vhci1jYXRlZ29yeS1saXN0Jz5cblx0XHRcdHsjZWFjaCBHZWFyLmNhdGVnb3JpZXMgYXMgY2F0ZWdvcnl9XG5cdFx0XHRcdDxHZWFyQ2F0ZWdvcnkge21vZGV9IHtjYXRlZ29yeX0gLz5cblx0XHRcdHsvZWFjaH1cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2RldGFpbHM+IiwiPHNjcmlwdD5cblx0ZXhwb3J0IGxldCBjaGFyYWN0ZXIsIG1vZGVcbjwvc2NyaXB0PlxuXG5cbjxkaXYgY2xhc3M9J2JvZHktcGFydHMtc2VjdGlvbic+XG5cdDxkaXYgY2xhc3M9J2xlZnQtY29sdW1uJz5cblx0XHQ8ZGl2IGNsYXNzPSdoZWFkLWxhYmVsJz5cblx0XHRcdDxkaXYgY2xhc3M9J2JvZHktcGFydC1uYW1lJz5cblx0XHRcdFx0eyRjaGFyYWN0ZXIuaGVhbHRoLmhlYWQubmFtZX1cblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz0nYm9keS1wYXJ0LW51bWJlcnMnPlxuXHRcdFx0XHR7I2lmIG1vZGUgPT0gJ3JlYWRvbmx5J31cblx0XHRcdFx0XHR7JGNoYXJhY3Rlci5oZWFsdGguaGVhZC5zY29yZX1cblx0XHRcdFx0ezplbHNlfVxuXHRcdFx0XHRcdDxpbnB1dCB0eXBlPSdudW1iZXInXG5cdFx0XHRcdFx0XHRiaW5kOnZhbHVlPSd7JGNoYXJhY3Rlci5oZWFsdGguaGVhZC5jdXJyZW50fSdcblx0XHRcdFx0XHRcdG1pbj0nLXskY2hhcmFjdGVyLmhlYWx0aC5oZWFkLnNjb3JlfSdcblx0XHRcdFx0XHRcdG1heD0neyRjaGFyYWN0ZXIuaGVhbHRoLmhlYWQuc2NvcmV9J1xuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdHsvaWZ9IC8geyRjaGFyYWN0ZXIuaGVhbHRoLmhlYWQuc2NvcmV9XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPSdsZWZ0LWFybS1sYWJlbCc+XG5cdFx0XHQ8ZGl2IGNsYXNzPSdib2R5LXBhcnQtbmFtZSc+XG5cdFx0XHRcdHskY2hhcmFjdGVyLmhlYWx0aC5sZWZ0QXJtLm5hbWV9XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9J2JvZHktcGFydC1udW1iZXJzJz5cblx0XHRcdFx0eyNpZiBtb2RlID09ICdyZWFkb25seSd9XG5cdFx0XHRcdFx0eyRjaGFyYWN0ZXIuaGVhbHRoLmxlZnRBcm0uc2NvcmV9XG5cdFx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0XHQ8aW5wdXQgdHlwZT0nbnVtYmVyJ1xuXHRcdFx0XHRcdFx0YmluZDp2YWx1ZT0neyRjaGFyYWN0ZXIuaGVhbHRoLmxlZnRBcm0uY3VycmVudH0nXG5cdFx0XHRcdFx0XHRtaW49Jy17JGNoYXJhY3Rlci5oZWFsdGgubGVmdEFybS5zY29yZX0nXG5cdFx0XHRcdFx0XHRtYXg9J3skY2hhcmFjdGVyLmhlYWx0aC5sZWZ0QXJtLnNjb3JlfSdcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHR7L2lmfSAvIHskY2hhcmFjdGVyLmhlYWx0aC5sZWZ0QXJtLnNjb3JlfVxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz0nbGVmdC1sZWctbGFiZWwnPlxuXHRcdFx0PGRpdiBjbGFzcz0nYm9keS1wYXJ0LW5hbWUnPlxuXHRcdFx0XHR7JGNoYXJhY3Rlci5oZWFsdGgubGVmdExlZy5uYW1lfVxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPSdib2R5LXBhcnQtbnVtYmVycyc+XG5cdFx0XHRcdHsjaWYgbW9kZSA9PSAncmVhZG9ubHknfVxuXHRcdFx0XHRcdHskY2hhcmFjdGVyLmhlYWx0aC5sZWZ0TGVnLnNjb3JlfVxuXHRcdFx0XHR7OmVsc2V9XG5cdFx0XHRcdFx0PGlucHV0IHR5cGU9J251bWJlcidcblx0XHRcdFx0XHRcdGJpbmQ6dmFsdWU9J3skY2hhcmFjdGVyLmhlYWx0aC5sZWZ0TGVnLmN1cnJlbnR9J1xuXHRcdFx0XHRcdFx0bWluPScteyRjaGFyYWN0ZXIuaGVhbHRoLmxlZnRMZWcuc2NvcmV9J1xuXHRcdFx0XHRcdFx0bWF4PSd7JGNoYXJhY3Rlci5oZWFsdGgubGVmdExlZy5zY29yZX0nXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0ey9pZn0gLyB7JGNoYXJhY3Rlci5oZWFsdGgubGVmdExlZy5zY29yZX1cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cblx0PGRpdiBjbGFzcz0nY2VudGVyLWNvbHVtbic+XG5cdFx0PGRpdiBjbGFzcz0naGVhZC1sZXZlbCc+XG5cdFx0XHQ8ZGl2IGNsYXNzPSdoZWFkIGJvZHktcGFydCcgLz5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPSd0b3Jzby1sZXZlbCc+XG5cdFx0XHQ8ZGl2IGNsYXNzPSdsZWZ0LWFybSBhcm0gYm9keS1wYXJ0JyAvPlxuXHRcdFx0PGRpdiBjbGFzcz0ndG9yc28gYm9keS1wYXJ0JyAvPlxuXHRcdFx0PGRpdiBjbGFzcz0ncmlnaHQtYXJtIGFybSBib2R5LXBhcnQnIC8+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz0nbGVncy1sZXZlbCc+XG5cdFx0XHQ8ZGl2IGNsYXNzPSdsZWZ0LWxlZyBsZWcgYm9keS1wYXJ0JyAvPlxuXHRcdFx0PGRpdiBjbGFzcz0ncmlnaHQtbGVnIGxlZyBib2R5LXBhcnQnIC8+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuXHQ8ZGl2IGNsYXNzPSdyaWdodC1jb2x1bW4nPlxuXHRcdDxkaXYgY2xhc3M9J3RvcnNvLWxhYmVsJz5cblx0XHRcdDxkaXYgY2xhc3M9J2JvZHktcGFydC1uYW1lJz5cblx0XHRcdFx0eyRjaGFyYWN0ZXIuaGVhbHRoLnRvcnNvLm5hbWV9XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9J2JvZHktcGFydC1udW1iZXJzJz5cblx0XHRcdFx0eyNpZiBtb2RlID09ICdyZWFkb25seSd9XG5cdFx0XHRcdFx0eyRjaGFyYWN0ZXIuaGVhbHRoLnRvcnNvLnNjb3JlfVxuXHRcdFx0XHR7OmVsc2V9XG5cdFx0XHRcdFx0PGlucHV0IHR5cGU9J251bWJlcidcblx0XHRcdFx0XHRcdGJpbmQ6dmFsdWU9J3skY2hhcmFjdGVyLmhlYWx0aC50b3Jzby5jdXJyZW50fSdcblx0XHRcdFx0XHRcdG1pbj0nLXskY2hhcmFjdGVyLmhlYWx0aC50b3Jzby5zY29yZX0nXG5cdFx0XHRcdFx0XHRtYXg9J3skY2hhcmFjdGVyLmhlYWx0aC50b3Jzby5zY29yZX0nXG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0ey9pZn0gLyB7JGNoYXJhY3Rlci5oZWFsdGgudG9yc28uc2NvcmV9XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblx0XHQ8ZGl2IGNsYXNzPSdyaWdodC1hcm0tbGFiZWwnPlxuXHRcdFx0PGRpdiBjbGFzcz0nYm9keS1wYXJ0LW5hbWUnPlxuXHRcdFx0XHR7JGNoYXJhY3Rlci5oZWFsdGgucmlnaHRBcm0ubmFtZX1cblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz0nYm9keS1wYXJ0LW51bWJlcnMnPlxuXHRcdFx0XHR7I2lmIG1vZGUgPT0gJ3JlYWRvbmx5J31cblx0XHRcdFx0XHR7JGNoYXJhY3Rlci5oZWFsdGgucmlnaHRBcm0uc2NvcmV9XG5cdFx0XHRcdHs6ZWxzZX1cblx0XHRcdFx0XHQ8aW5wdXQgdHlwZT0nbnVtYmVyJ1xuXHRcdFx0XHRcdFx0YmluZDp2YWx1ZT0neyRjaGFyYWN0ZXIuaGVhbHRoLnJpZ2h0QXJtLmN1cnJlbnR9J1xuXHRcdFx0XHRcdFx0bWluPScteyRjaGFyYWN0ZXIuaGVhbHRoLnJpZ2h0QXJtLnNjb3JlfSdcblx0XHRcdFx0XHRcdG1heD0neyRjaGFyYWN0ZXIuaGVhbHRoLnJpZ2h0QXJtLnNjb3JlfSdcblx0XHRcdFx0XHQvPlxuXHRcdFx0XHR7L2lmfSAvIHskY2hhcmFjdGVyLmhlYWx0aC5yaWdodEFybS5zY29yZX1cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHRcdDxkaXYgY2xhc3M9J3JpZ2h0LWxlZy1sYWJlbCc+XG5cdFx0XHQ8ZGl2IGNsYXNzPSdib2R5LXBhcnQtbmFtZSc+XG5cdFx0XHRcdHskY2hhcmFjdGVyLmhlYWx0aC5yaWdodExlZy5uYW1lfVxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPSdib2R5LXBhcnQtbnVtYmVycyc+XG5cdFx0XHRcdHsjaWYgbW9kZSA9PSAncmVhZG9ubHknfVxuXHRcdFx0XHRcdHskY2hhcmFjdGVyLmhlYWx0aC5yaWdodExlZy5zY29yZX1cblx0XHRcdFx0ezplbHNlfVxuXHRcdFx0XHRcdDxpbnB1dCB0eXBlPSdudW1iZXInXG5cdFx0XHRcdFx0XHRiaW5kOnZhbHVlPSd7JGNoYXJhY3Rlci5oZWFsdGgucmlnaHRMZWcuY3VycmVudH0nXG5cdFx0XHRcdFx0XHRtaW49Jy17JGNoYXJhY3Rlci5oZWFsdGgucmlnaHRMZWcuc2NvcmV9J1xuXHRcdFx0XHRcdFx0bWF4PSd7JGNoYXJhY3Rlci5oZWFsdGgucmlnaHRMZWcuc2NvcmV9J1xuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdHsvaWZ9IC8geyRjaGFyYWN0ZXIuaGVhbHRoLnJpZ2h0TGVnLnNjb3JlfVxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuPC9kaXY+XG5cblxuPHN0eWxlPlxuXHRpbnB1dFt0eXBlPSdudW1iZXInXSB7XG5cdFx0d2lkdGg6IHZhcigtLXMyMDApO1xuXHR9XG5cdC5ib2R5LXBhcnRzLXNlY3Rpb24ge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdFx0bWF4LXdpZHRoOiAxMDAlO1xuXHR9XG5cdGRpdltjbGFzcyo9Y29sdW1uXSB7XG5cdFx0ZGlzcGxheTogYmxvY2s7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHRcdHdpZHRoOiBhdXRvO1xuXHR9XG5cdC5jZW50ZXItY29sdW1uIHtcblx0XHRtYXJnaW4tdG9wOiAxMHB4O1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHR3aWR0aDogMTAwJTtcblx0fVxuXHRkaXZbY2xhc3MqPS1sYWJlbF0ge1xuXHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcblx0XHRoZWlnaHQ6IDEwcHg7XG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHR3aWR0aDogMTAwJTtcblx0fVxuXHQuaGVhZC1sYWJlbCwgLnRvcnNvLWxhYmVsIHtcblx0XHR0b3A6IDMwcHg7XG5cdH1cblx0LmxlZnQtYXJtLWxhYmVsLCAucmlnaHQtYXJtLWxhYmVsIHtcblx0XHR0b3A6IDEyMHB4O1xuXHR9XG5cdC5sZWZ0LWxlZy1sYWJlbCwgLnJpZ2h0LWxlZy1sYWJlbCB7XG5cdFx0dG9wOiAyMTBweDtcblx0fVxuXHQuYm9keS1wYXJ0IHtcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiBsaW1lO1xuXHR9XG5cdC5ib2R5LXBhcnQtbnVtYmVycyB7XG5cdFx0bWFyZ2luOiA1cHg7XG5cdH1cblx0ZGl2W2NsYXNzKj1sZXZlbF0ge1xuXHRcdGRpc3BsYXk6IGZsZXg7XG5cdFx0anVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cdH1cblx0LmhlYWQge1xuXHRcdGJvcmRlci1yYWRpdXM6IDUwJTtcblx0XHRib3JkZXI6IDFweDtcblx0XHRoZWlnaHQ6IDUwcHg7XG5cdFx0bWFyZ2luLWJvdHRvbTogNXB4O1xuXHRcdHdpZHRoOiA1MHB4O1xuXHR9XG5cdC5hcm0ge1xuXHRcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDE1cHg7XG5cdFx0Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDE1cHg7XG5cdFx0aGVpZ2h0OiAxNDBweDtcblx0XHR3aWR0aDogMjBweDtcblx0fVxuXHQubGVmdC1hcm0ge1xuXHRcdGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDMwcHg7XG5cdH1cblx0LnJpZ2h0LWFybSB7XG5cdFx0Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDMwcHg7XG5cdH1cblx0LnRvcnNvIHtcblx0XHRjb2xvcjogcmdiYSgxNSwgMzAsIDE1LCAxKTtcblx0XHRoZWlnaHQ6IDE1MHB4O1xuXHRcdG1hcmdpbjogMCA1cHg7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHRcdHdpZHRoOiA3MHB4O1xuXHR9XG5cdC5sZWcge1xuXHRcdGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAxNXB4O1xuXHRcdGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDE1cHg7XG5cdFx0aGVpZ2h0OiAxNjBweDtcblx0XHR3aWR0aDogMjhweDtcblx0fVxuXHQubGVmdC1sZWcge1xuXHRcdG1hcmdpbi1yaWdodDogMTRweDtcblx0fVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgQm9keVBhcnRzIGZyb20gJy4vQm9keVBhcnRzLnN2ZWx0ZSdcblx0aW1wb3J0IHsgY2hhcmFjdGVyIH0gZnJvbSAnc3RvcmVzL2NoYXJhY3RlclN0b3JlLmpzJ1xuXG5cdGV4cG9ydCBsZXQgbW9kZVxuPC9zY3JpcHQ+XG5cblxuPGRldGFpbHMgY2xhc3M9J3NoZWV0LWRldGFpbHMnIGNsb3NlPlxuXHQ8c3VtbWFyeSBjbGFzcz0nc2hlZXQtY2FyZC10aXRsZSc+XG5cdFx0SGVhbHRoXG5cdDwvc3VtbWFyeT5cblx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZCc+XG5cdFx0PEJvZHlQYXJ0cyB7Y2hhcmFjdGVyfSB7bW9kZX0gLz5cblx0PC9kaXY+XG48L2RldGFpbHM+IiwiaW1wb3J0IERlY29tcHJlc3NDaGFyYWN0ZXIgZnJvbSAnLi9EZWNvbXByZXNzQ2hhcmFjdGVyJ1xuXG5leHBvcnQgZGVmYXVsdCAodXNlcklkKSA9PiB7XG5cdHJldHVybiBmZXRjaChcblx0XHRgLy5uZXRsaWZ5L2Z1bmN0aW9ucy9jaGFyYWN0ZXItcmVhZGAsIHtcblx0XHRcdG1ldGhvZDogYFBPU1RgLFxuXHRcdFx0Ym9keTogSlNPTi5zdHJpbmdpZnkodXNlcklkKVxuXHRcdH1cblx0KVxuXHQudGhlbihyZXMgPT4gcmVzLmpzb24oKSlcbn0iLCI8c2NyaXB0PlxuICAgIGltcG9ydCBMb2FkQ2hhcmFjdGVyIGZyb20gJ2RhdGFiYXNlL0xvYWRDaGFyYWN0ZXIuanMnXG4gICAgaW1wb3J0IHsgYXV0aFVzZXJTdG9yZSB9IGZyb20gJ3N0b3Jlcy9uZXRsaWZ5U3RvcmUuanMnXG4gICAgaW1wb3J0IHsgY2hhcmFjdGVyIH0gZnJvbSAnc3RvcmVzL2NoYXJhY3RlclN0b3JlLmpzJ1xuXG4gICAgY29uc3QgbG9hZENoYXJhY3RlciA9ICgpID0+IHtcbiAgICAgICAgJGNoYXJhY3RlciA9IExvYWRDaGFyYWN0ZXIoJGF1dGhVc2VyU3RvcmUpXG5cdH1cbjwvc2NyaXB0PlxuXG5cbjxidXR0b25cbiAgICBjbGFzcz0nc21hbGwtY250ci1idG4nXG4gICAgb246Y2xpY2s9e2xvYWRDaGFyYWN0ZXJ9PlxuICAgIExvYWRcbjwvYnV0dG9uPiIsIjxzY3JpcHQ+XG5cdGltcG9ydCB7IGNoYXJhY3RlciB9IGZyb20gJ3N0b3Jlcy9jaGFyYWN0ZXJTdG9yZS5qcydcblxuXHRleHBvcnQgbGV0IG1vZGVcbjwvc2NyaXB0PlxuXG5cbjxkZXRhaWxzIGNsYXNzPSdzaGVldC1kZXRhaWxzJyBjbG9zZT5cblx0PHN1bW1hcnkgY2xhc3M9J3NoZWV0LWNhcmQtdGl0bGUnPlxuXHRcdE5vdGVzXG5cdDwvc3VtbWFyeT5cblx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZCc+XG5cdFx0eyNpZiBtb2RlID09ICdlZGl0J31cblx0XHRcdDx0ZXh0YXJlYSBjbGFzcz0nc2hlZXQtbm90ZXMtYmxvY2snIHdyYXA9J3NvZnQnIGJpbmQ6dmFsdWU9eyRjaGFyYWN0ZXIubWV0YS5ub3Rlc30gLz5cblx0XHR7OmVsc2V9XG5cdFx0XHQ8ZGl2IGNsYXNzPSdzaGVldC1ub3Rlcy1ibG9jayc+eyRjaGFyYWN0ZXIubWV0YS5ub3Rlc308L2Rpdj5cblx0XHR7L2lmfVxuXHQ8L2Rpdj5cbjwvZGV0YWlscz5cblxuXG48c3R5bGU+XG5cdC5zaGVldC1ub3Rlcy1ibG9jayB7XG5cdFx0Y29sb3I6IGxpbWU7XG5cdFx0Zm9udC1mYW1pbHk6IHZhcigtLWdsb2JhbC1mb250KTtcblx0XHRoZWlnaHQ6IDEwMCU7XG5cdFx0aGVpZ2h0OiB2YXIoLS1zMTAwMCk7XG5cdFx0b3ZlcmZsb3c6IGF1dG87XG5cdFx0cGFkZGluZzogdmFyKC0tczEwMCk7XG5cdFx0cmVzaXplOiBub25lO1xuXHRcdHRleHQtYWxpZ246IGxlZnQ7XG5cdFx0d2lkdGg6IGNhbGMoMTAwJSAtIHZhcigtLXMyMDApKTtcblx0fVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgeyBjaGFyYWN0ZXIgfSBmcm9tICdzdG9yZXMvY2hhcmFjdGVyU3RvcmUuanMnXG5cblx0ZXhwb3J0IGxldCBtb2RlXG48L3NjcmlwdD5cblxuXG48ZGV0YWlscyBjbGFzcz0nc2hlZXQtZGV0YWlscycgY2xvc2U+XG5cdDxzdW1tYXJ5IGNsYXNzPSdzaGVldC1jYXJkLXRpdGxlJz5cblx0XHRQcm9wZXJ0aWVzXG5cdDwvc3VtbWFyeT5cblx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZCc+XG5cdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1ib2R5Jz5cblx0XHRcdDxkaXYgY2xhc3M9J3NoZWV0LWNhcmQtYmxvY2snPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPSdzaGVldC1jYXJkLWl0ZW0nPlxuXHRcdFx0XHRcdHskY2hhcmFjdGVyLnByb3BzLnNwZWVkLm5hbWV9OiB7JGNoYXJhY3Rlci5wcm9wcy5zcGVlZC5zY29yZX1cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxkaXYgY2xhc3M9J3NoZWV0LWNhcmQtaXRlbSc+XG5cdFx0XHRcdFx0eyRjaGFyYWN0ZXIucHJvcHMuY2FycnkubmFtZX06IHskY2hhcmFjdGVyLnByb3BzLmNhcnJ5LmN1cnJlbnR9IC8geyRjaGFyYWN0ZXIucHJvcHMuY2Fycnkuc2NvcmV9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPSdzaGVldC1jYXJkLWl0ZW0nPlxuXHRcdFx0XHRcdFhQOiB7JGNoYXJhY3Rlci5wcm9wcy5leHBlcmllbmNlLnJlbWFpbmluZ30gLyB7JGNoYXJhY3Rlci5wcm9wcy5leHBlcmllbmNlLnNjb3JlfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1pdGVtJz5cblx0XHRcdFx0XHR7JGNoYXJhY3Rlci5wcm9wcy5wc3ljaGUubmFtZX06IFxuXHRcdFx0XHRcdHsjaWYgbW9kZSA9PSAnZWRpdCd9XG5cdFx0XHRcdFx0XHQ8aW5wdXQgdHlwZT0nbnVtYmVyJ1xuXHRcdFx0XHRcdFx0XHRjbGFzcz0nY3VycmVudC12YWx1ZSdcblx0XHRcdFx0XHRcdFx0YmluZDp2YWx1ZT17JGNoYXJhY3Rlci5wcm9wcy5wc3ljaGUuY3VycmVudH1cblx0XHRcdFx0XHRcdFx0bWluPTAgbWF4PXskY2hhcmFjdGVyLnByb3BzLnBzeWNoZS5zY29yZX1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0ezplbHNlIGlmIG1vZGUgPT0gJ3JlYWRvbmx5J31cblx0XHRcdFx0XHRcdHskY2hhcmFjdGVyLnByb3BzLnBzeWNoZS5jdXJyZW50fVxuXHRcdFx0XHRcdHsvaWZ9IC8geyRjaGFyYWN0ZXIucHJvcHMucHN5Y2hlLnNjb3JlfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1ibG9jayc+XG5cdFx0XHRcdDxkaXYgY2xhc3M9J3NoZWV0LWNhcmQtaXRlbSc+XG5cdFx0XHRcdFx0eyRjaGFyYWN0ZXIucHJvcHMuZG9kZ2UubmFtZX06IFxuXHRcdFx0XHRcdHskY2hhcmFjdGVyLnByb3BzLmRvZGdlLnNjb3JlfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1pdGVtJz5cblx0XHRcdFx0XHR7JGNoYXJhY3Rlci5wcm9wcy5ibG9jay5uYW1lfTogXG5cdFx0XHRcdFx0eyRjaGFyYWN0ZXIucHJvcHMuYmxvY2suc2NvcmV9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPSdzaGVldC1jYXJkLWl0ZW0nPlxuXHRcdFx0XHRcdHskY2hhcmFjdGVyLnByb3BzLmludGVsbGVjdC5uYW1lfTogXG5cdFx0XHRcdFx0eyRjaGFyYWN0ZXIucHJvcHMuaW50ZWxsZWN0LnNjb3JlfVxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1pdGVtJz5cblx0XHRcdFx0XHR7JGNoYXJhY3Rlci5wcm9wcy5sdWNrLm5hbWV9OiBcblx0XHRcdFx0XHR7I2lmIG1vZGUgPT0gJ2VkaXQnfVxuXHRcdFx0XHRcdFx0PGlucHV0IHR5cGU9J251bWJlcidcblx0XHRcdFx0XHRcdFx0Y2xhc3M9J2N1cnJlbnQtdmFsdWUnXG5cdFx0XHRcdFx0XHRcdGJpbmQ6dmFsdWU9eyRjaGFyYWN0ZXIucHJvcHMubHVjay5jdXJyZW50fVxuXHRcdFx0XHRcdFx0XHRtaW49MCBtYXg9eyRjaGFyYWN0ZXIucHJvcHMubHVjay5zY29yZX1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0ezplbHNlIGlmIG1vZGUgPT0gJ3JlYWRvbmx5J31cblx0XHRcdFx0XHRcdHskY2hhcmFjdGVyLnByb3BzLmx1Y2suY3VycmVudH1cblx0XHRcdFx0XHR7L2lmfSAvIHskY2hhcmFjdGVyLnByb3BzLmx1Y2suc2NvcmV9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cdDwvZGl2PlxuPC9kZXRhaWxzPlxuXG5cbjxzdHlsZT5cblx0LmN1cnJlbnQtdmFsdWUge1xuXHRcdHdpZHRoOiAyMCU7XG5cdH1cbjwvc3R5bGU+IiwiY29uc3QgY29tcHJlc3NBYmlsaXRpZXMgPSAoY2hhciwgYykgPT4ge1xuXHRjaGFyLkFiID0gYy5hYmlsaXRpZXMubWFwKG0gPT4ge1xuXHRcdHJldHVybiB7XG5cdFx0XHRpOiBtLmlkLFxuXHRcdFx0dDogbS50YWtlblxuXHRcdH1cblx0fSlcblx0cmV0dXJuIGNoYXJcbn1cblxuY29uc3QgY29tcHJlc3NHZWFyID0gKGNoYXIsIGMsIGFidiwgdHlwZSkgPT4ge1xuXHRmb3IgKGNvbnN0IGl0ZW0gaW4gYy5nZWFyW3R5cGVdLmludmVudG9yeSkge1xuXHRcdGNoYXJbYWJ2XS5wdXNoKHtcblx0XHRcdGk6IGMuZ2Vhclt0eXBlXS5pbnZlbnRvcnlbaXRlbV0uaWQsXG5cdFx0XHRxOiBjLmdlYXJbdHlwZV0uaW52ZW50b3J5W2l0ZW1dLnF0eVxuXHRcdH0pXG5cdH1cblx0cmV0dXJuIGNoYXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGMpID0+IHtcblx0bGV0IGNoYXIgPSB7XG5cdFx0TWk6IGMubWV0YS5pZCxcblx0XHRNdTogYy5tZXRhLnVzZXIsXG5cdFx0TWM6IGMubWV0YS5jcmVhdGVkLFxuXHRcdE1tOiBjLm1ldGEubW9kaWZpZWQsXG5cdFx0TW46IGMubWV0YS5ub3Rlcyxcblx0XHRDbTogYy5tZXRhLmNvb3JkaW5hdGVzLm1hcCxcblx0XHRDeDogYy5tZXRhLmNvb3JkaW5hdGVzLngsXG5cdFx0Q3k6IGMubWV0YS5jb29yZGluYXRlcy55LFxuXHRcdFNjOiBjLm1ldGEuc3RhdHVzLmNvbXBsZXRlZCxcblx0XHRTbzogYy5tZXRhLnN0YXR1cy5vcGVuLFxuXHRcdFNzOiBjLm1ldGEuc3RhdHVzLnN0ZXAsXG5cdFx0RGE6IGMuZGVzYy5hZ2UudmFsdWUsXG5cdFx0RG46IGMuZGVzYy5uYW1lLnZhbHVlLFxuXHRcdERoOiBjLmRlc2MuaGFpci52YWx1ZSxcblx0XHREZTogYy5kZXNjLmhlaWdodC52YWx1ZSxcblx0XHREczogYy5kZXNjLnNleC52YWx1ZSxcblx0XHREazogYy5kZXNjLnNraW4udmFsdWUsXG5cdFx0RHc6IGMuZGVzYy53ZWlnaHQudmFsdWUsXG5cdFx0VGE6IGMudHJhaXRzLmFnaWxpdHkuc2NvcmUsXG5cdFx0VGI6IGMudHJhaXRzLmJyYWlucy5zY29yZSxcblx0XHRUYzogYy50cmFpdHMuY29uc3RpdHV0aW9uLnNjb3JlLFxuXHRcdFRkOiBjLnRyYWl0cy5kZW1lYW5vci5zY29yZSxcblx0XHRhYzogYy5za2lsbHMuYWNyb2JhdGljcy5zY29yZSxcblx0XHRsYTogYy5za2lsbHMubGFyY2VueS5zY29yZSxcblx0XHRyYTogYy5za2lsbHMucmFuZ2VkLnNjb3JlLFxuXHRcdHN0OiBjLnNraWxscy5zdGVhbHRoLnNjb3JlLFxuXHRcdG1kOiBjLnNraWxscy5tZWRpY2luZS5zY29yZSxcblx0XHRwZTogYy5za2lsbHMucGVyY2VwdGlvbi5zY29yZSxcblx0XHRzYzogYy5za2lsbHMuc2NpZW5jZS5zY29yZSxcblx0XHRzdTogYy5za2lsbHMuc3Vydml2YWwuc2NvcmUsXG5cdFx0YXQ6IGMuc2tpbGxzLmF0aGxldGljcy5zY29yZSxcblx0XHRidTogYy5za2lsbHMuYnVpbGQuc2NvcmUsXG5cdFx0ZHI6IGMuc2tpbGxzLmRyaXZlLnNjb3JlLFxuXHRcdG1lOiBjLnNraWxscy5tZWxlZS5zY29yZSxcblx0XHRsZTogYy5za2lsbHMubGVhZGVyc2hpcC5zY29yZSxcblx0XHRwcjogYy5za2lsbHMucGVyZm9ybS5zY29yZSxcblx0XHRzbzogYy5za2lsbHMuc29jaWFsaXplLnNjb3JlLFxuXHRcdHRhOiBjLnNraWxscy50YW1lLnNjb3JlLFxuXHRcdFBsOiBjLnByb3BzLmx1Y2suY3VycmVudCxcblx0XHRQcDogYy5wcm9wcy5wc3ljaGUuY3VycmVudCxcblx0XHRoRDogYy5oZWFsdGguaGVhZC5jdXJyZW50LFxuXHRcdHJBOiBjLmhlYWx0aC5yaWdodEFybS5jdXJyZW50LFxuXHRcdGxBOiBjLmhlYWx0aC5sZWZ0QXJtLmN1cnJlbnQsXG5cdFx0dE86IGMuaGVhbHRoLnRvcnNvLmN1cnJlbnQsXG5cdFx0bEw6IGMuaGVhbHRoLmxlZnRMZWcuY3VycmVudCxcblx0XHRyTDogYy5oZWFsdGgucmlnaHRMZWcuY3VycmVudCxcblx0XHRBYjogW10sXG5cdFx0R2E6IFtdLFxuXHRcdEdtOiBbXSxcblx0XHRHcjogW10sXG5cdFx0R286IFtdLFxuXHRcdEdlOiBbXVxuXHR9XG5cblx0Y2hhciA9IGNvbXByZXNzQWJpbGl0aWVzKGNoYXIsIGMpXG5cblx0Y2hhciA9IGNvbXByZXNzR2VhcihjaGFyLCBjLCAnR2EnLCAnYXJtb3InKVxuXHRjaGFyID0gY29tcHJlc3NHZWFyKGNoYXIsIGMsICdHbScsICdtZWxlZScpXG5cdGNoYXIgPSBjb21wcmVzc0dlYXIoY2hhciwgYywgJ0dyJywgJ3JhbmdlZCcpXG5cdGNoYXIgPSBjb21wcmVzc0dlYXIoY2hhciwgYywgJ0dvJywgJ2FtbW8nKVxuXHRjaGFyID0gY29tcHJlc3NHZWFyKGNoYXIsIGMsICdHZScsICdlcXVpcG1lbnQnKVxuXG5cdHJldHVybiBjaGFyXG59IiwiaW1wb3J0IENvbXByZXNzQ2hhcmFjdGVyIGZyb20gJy4vQ29tcHJlc3NDaGFyYWN0ZXInXHJcblxyXG5leHBvcnQgZGVmYXVsdCAoY2hhcmFjdGVyKSA9PiB7XHJcblx0cmV0dXJuIGZldGNoKFxyXG5cdFx0YC8ubmV0bGlmeS9mdW5jdGlvbnMvY2hhcmFjdGVyLWNyZWF0ZWAsIHtcclxuXHRcdFx0bWV0aG9kOiBgUE9TVGAsXHJcblx0XHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KENvbXByZXNzQ2hhcmFjdGVyKGNoYXJhY3RlcikpXHJcblx0XHR9XHJcblx0KVxyXG5cdC50aGVuKHJlcyA9PiByZXMuanNvbigpKVxyXG59IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQgU2F2ZUNoYXJhY3RlciBmcm9tICdkYXRhYmFzZS9TYXZlQ2hhcmFjdGVyLmpzJ1xuICAgIGltcG9ydCB7IGF1dGhVc2VyU3RvcmUgfSBmcm9tICdzdG9yZXMvbmV0bGlmeVN0b3JlLmpzJ1xuXHRpbXBvcnQgeyBjaGFyYWN0ZXIgfSBmcm9tICdzdG9yZXMvY2hhcmFjdGVyU3RvcmUuanMnXG5cbiAgICBjb25zdCBjcmVhdGVDaGFyYWN0ZXIgPSAoKSA9PiB7XG5cdFx0JGNoYXJhY3Rlci5maW5hbGl6ZSgkYXV0aFVzZXJTdG9yZS5pZClcblx0XHQkY2hhcmFjdGVyID0gU2F2ZUNoYXJhY3RlcigkY2hhcmFjdGVyKVxuXHRcdGNvbnNvbGUubG9nKCRjaGFyYWN0ZXIpXG5cdH1cbjwvc2NyaXB0PlxuXG5cbjxidXR0b25cbiAgICBjbGFzcz0nc21hbGwtY250ci1idG4nXG4gICAgb246Y2xpY2s9e2NyZWF0ZUNoYXJhY3Rlcn0+XG4gICAgU2F2ZVxuPC9idXR0b24+IiwiPHNjcmlwdD5cblx0aW1wb3J0IHsgY2hhcmFjdGVyIH0gZnJvbSAnc3RvcmVzL2NoYXJhY3RlclN0b3JlLmpzJ1xuPC9zY3JpcHQ+XG5cblxuPGRldGFpbHMgY2xhc3M9J3NoZWV0LWRldGFpbHMnIGNsb3NlPlxuXHQ8c3VtbWFyeSBjbGFzcz0nc2hlZXQtY2FyZC10aXRsZSc+XG5cdFx0U2tpbGxzXG5cdDwvc3VtbWFyeT5cblx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZCc+XG5cdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1ib2R5Jz5cblx0XHRcdHsjZWFjaCBPYmplY3QudmFsdWVzKCRjaGFyYWN0ZXIudHJhaXRzKSBhcyB0cmFpdH1cblx0XHRcdFx0PGRpdiBjbGFzcz0nc2hlZXQtY2FyZC1ibG9jayc+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz0ncGFyZW50LXRyYWl0Jz5cblx0XHRcdFx0XHRcdHt0cmFpdC5uYW1lfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdHsjZWFjaCBPYmplY3QudmFsdWVzKCRjaGFyYWN0ZXIuc2tpbGxzKSBhcyBza2lsbH1cblx0XHRcdFx0XHRcdHsjaWYgdHJhaXQubmFtZSA9PSBza2lsbC5wYXJlbnR9XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9J3NoZWV0LWNhcmQtaXRlbSc+XG5cdFx0XHRcdFx0XHRcdFx0e3NraWxsLm5hbWV9OiB7c2tpbGwuc2NvcmV9XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0ey9pZn1cblx0XHRcdFx0XHR7L2VhY2h9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0ey9lYWNofVxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cbjwvZGV0YWlscz5cblxuXG48c3R5bGU+XG5cdC5zaGVldC1jYXJkLWJsb2NrIHtcblx0XHRib3JkZXI6IDFweCBkb3R0ZWQgbGltZTtcblx0XHR3aWR0aDogMTAwJTtcblx0fVxuXHQucGFyZW50LXRyYWl0IHtcblx0XHRmb250LXNpemU6IHZhcigtLXMxMTApO1xuXHRcdGZvbnQtd2VpZ2h0OiBib2xkO1xuXHRcdG1hcmdpbjogdmFyKC0tczEwMCk7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHR9XG48L3N0eWxlPiIsIjxzY3JpcHQ+XG5cdGltcG9ydCB7IGNoYXJhY3RlciB9IGZyb20gJ3N0b3Jlcy9jaGFyYWN0ZXJTdG9yZS5qcydcbjwvc2NyaXB0PlxuXG5cbjxkZXRhaWxzIGNsYXNzPSdzaGVldC1kZXRhaWxzJyBjbG9zZT5cblx0PHN1bW1hcnkgY2xhc3M9J3NoZWV0LWNhcmQtdGl0bGUnPlxuXHRcdFRyYWl0c1xuXHQ8L3N1bW1hcnk+XG5cdDxkaXYgY2xhc3M9J3NoZWV0LWNhcmQnPlxuXHRcdDxkaXYgY2xhc3M9J3NoZWV0LWNhcmQtYm9keSc+XG5cdFx0XHR7I2VhY2ggT2JqZWN0LnZhbHVlcygkY2hhcmFjdGVyLnRyYWl0cykgYXMgdHJhaXR9XG5cdFx0XHRcdDxkaXYgY2xhc3M9J3NoZWV0LWNhcmQtYmxvY2snPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9J3NoZWV0LWNhcmQtaXRlbSc+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz0ndHJhaXQtbmFtZSc+XG5cdFx0XHRcdFx0XHRcdHt0cmFpdC5uYW1lfToge3RyYWl0LnNjb3JlfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdHsvZWFjaH1cblx0XHQ8L2Rpdj5cblx0PC9kaXY+XG48L2RldGFpbHM+XG5cblxuPHN0eWxlPlxuXHQudHJhaXQtbmFtZSB7XG5cdFx0Zm9udC1zaXplOiB2YXIoLS1zMTEwKTtcblx0XHRmb250LXdlaWdodDogYm9sZDtcblx0fVxuPC9zdHlsZT4iLCI8c2NyaXB0PlxuXHRpbXBvcnQgQWJpbGl0aWVzIGZyb20gJy4vQWJpbGl0aWVzLnN2ZWx0ZSdcblx0aW1wb3J0IERlbGV0ZUNoYXJhY3RlckJ1dHRvbiBmcm9tICcuL0RlbGV0ZUNoYXJhY3RlckJ1dHRvbi5zdmVsdGUnXG5cdGltcG9ydCBEZXNjcmlwdGlvbiBmcm9tICcuL0Rlc2NyaXB0aW9uLnN2ZWx0ZSdcblx0aW1wb3J0IEdlYXIgZnJvbSAnLi9HZWFyLnN2ZWx0ZSdcblx0aW1wb3J0IEhlYWx0aCBmcm9tICcuL0hlYWx0aC5zdmVsdGUnXG5cdGltcG9ydCBMb2FkQ2hhcmFjdGVyQnV0dG9uIGZyb20gJy4vTG9hZENoYXJhY3RlckJ1dHRvbi5zdmVsdGUnXG5cdGltcG9ydCBOb3RlcyBmcm9tICcuL05vdGVzLnN2ZWx0ZSdcblx0aW1wb3J0IFByb3BlcnRpZXMgZnJvbSAnLi9Qcm9wZXJ0aWVzLnN2ZWx0ZSdcblx0aW1wb3J0IFNhdmVDaGFyYWN0ZXJCdXR0b24gZnJvbSAnLi9TYXZlQ2hhcmFjdGVyQnV0dG9uLnN2ZWx0ZSdcblx0aW1wb3J0IFNraWxscyBmcm9tICcuL1NraWxscy5zdmVsdGUnXG5cdGltcG9ydCBUcmFpdHMgZnJvbSAnLi9UcmFpdHMuc3ZlbHRlJ1xuXG5cdGV4cG9ydCBsZXQgbW9kZVxuPC9zY3JpcHQ+XG5cblxuPGRpdiBjbGFzcz1cImNoYXJhY3Rlci1zaGVldFwiPlxuXHQ8RGVzY3JpcHRpb24ge21vZGV9IC8+XG5cdDxUcmFpdHMgLz5cblx0PFNraWxscyAvPlxuXHQ8UHJvcGVydGllcyB7bW9kZX0gLz5cblx0PEhlYWx0aCB7bW9kZX0gLz5cblx0PEFiaWxpdGllcyAvPlxuXHQ8R2VhciB7bW9kZX0gLz5cblx0PE5vdGVzIHttb2RlfSAvPlxuPC9kaXY+XG48ZGl2IGNsYXNzPSdidG4tcm93Jz5cblx0PERlbGV0ZUNoYXJhY3RlckJ1dHRvbiAvPlxuXHQ8TG9hZENoYXJhY3RlckJ1dHRvbiAvPlxuXHQ8U2F2ZUNoYXJhY3RlckJ1dHRvbiAvPlxuPC9kaXY+XG5cblxuPHN0eWxlPlxuXHQuY2hhcmFjdGVyLXNoZWV0IHtcblx0XHRwYWRkaW5nOiB2YXIoLS1zMTAwKTtcblx0fVxuPC9zdHlsZT4iXSwibmFtZXMiOlsiRHJ1Z3NMaXN0IiwiRWxlY3Ryb25pY3NMaXN0IiwiRXF1aXBtZW50TGlzdCIsIk1lbGVlTGlzdCIsIlJhbmdlZExpc3QiLCJBbW1vTGlzdCIsIkFybW9yTGlzdCIsIkdlYXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJBb0JPLEdBQU8sSUFBQyxJQUFJOzs7NkJBQUUsR0FBTyxJQUFDLElBQUksQ0FBQyxDQUFDO29CQUFTLEdBQU8sSUFBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUk7Ozs7Ozs0QkFHekQsR0FBTyxJQUFDLEVBQUU7Ozs7NEJBR1YsR0FBTyxJQUFDLEdBQUc7Ozs7NEJBR1gsR0FBTyxJQUFDLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3RUFUYixHQUFPLElBQUMsSUFBSTs7eUVBQUUsR0FBTyxJQUFDLElBQUksQ0FBQyxDQUFDO3NCQUFTLEdBQU8sSUFBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLElBQUk7Ozt3RUFHekQsR0FBTyxJQUFDLEVBQUU7d0VBR1YsR0FBTyxJQUFDLEdBQUc7d0VBR1gsR0FBTyxJQUFDLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lDQVpW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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FqRXJCLElBQUk7Ozs7Ozs7O0VBWTRDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUs7Ozs7O0VBRTFCLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUs7Ozs7O0VBUTdCLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUs7Ozs7O0VBRXpCLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUs7Ozs7O0VBTXpCLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUs7Ozs7O0VBRTVCLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUs7Ozs7O0VBTTVCLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUs7Ozs7O0VBRTVCLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUs7Ozs7O0VBUTVCLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUs7Ozs7O0VBRXpCLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUs7Ozs7O0VBTXpCLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUs7Ozs7O0VBRTFCLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUs7Ozs7O0VBTTFCLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUs7Ozs7O0VBRTFCLFVBQVUsQ0FBQyxJQUFJLENB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QUk7Ozs7Z0NBU3BCLEdBQVUsSUFBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUs7Ozs7O2dDQUtyQyxHQUFVLElBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJOzs7Z0NBQzNCLEdBQVUsSUFBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUs7Ozs7Z0NBRzVCLEdBQVUsSUFBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUk7OztnQ0FDM0IsR0FBVSxJQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSzs7OztnQ0FHNUIsR0FBVSxJQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSTs7O2dDQUMvQixHQUFVLElBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLOzs7O2dDQUdoQyxHQUFVLElBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJOzs7O2dDQVNsQixHQUFVLElBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLOzs7O2VBbEMvQixHQUFJLE9BQUksTUFBTTtlQU1ULEdBQUksT0FBSSxVQUFVOzs7Ozs7O2VBb0J2QixHQUFJLE9BQUksTUFBTTtlQU1ULEdBQUksT0FBSSxVQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkVBMUMzQixHQUFVLElBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJOzJFQUFJLEdBQVUsSUFBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUs7MkVBRzNELEdBQVUsSUFBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUk7MkVBQUksR0FBVSxJQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTzs2RUFBSyxHQUFVLElBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLOzZFQUcxRixHQUFVLElBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxTQUFTOzZFQUFLLEdBQVUsSUFBQyxLQUFLLENBQUMsVUFBVSxDQUFDLEtBQUs7NkVBRy9FLEdBQVUsSUFBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUk7Ozs7Ozs7Ozs7Ozs7OzZFQVNwQixHQUFVLElBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLOzZFQUtyQyxHQUFVLElBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJOzZFQUMzQixHQUFVLElBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLOzZFQUc1QixHQUFVLElBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJOzZFQUMzQixHQUFVLElBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLOzZFQUc1QixHQUFVLElBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJOzZFQUMvQixHQUFVLElBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLOzZFQUdoQyxHQUFVLElBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs2RUFTbEIsR0FBVSxJQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXhEN0IsSUFBSTs7Ozs7Ozs7RUF5QkcsVUFBVSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsT0FBTzs7Ozs7RUEwQi9CLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdERoRCxNQUFNLGlCQUFpQixHQUFHLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSztBQUN2QyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJO0FBQ2hDLEVBQUUsT0FBTztBQUNULEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFO0FBQ1YsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUs7QUFDYixHQUFHO0FBQ0gsRUFBRSxFQUFDO0FBQ0gsQ0FBQyxPQUFPLElBQUk7QUFDWixFQUFDO0FBQ0Q7QUFDQSxNQUFNLFlBQVksR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksS0FBSztBQUM3QyxDQUFDLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLEVBQUU7QUFDNUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ2pCLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUU7QUFDckMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRztBQUN0QyxHQUFHLEVBQUM7QUFDSixFQUFFO0FBQ0YsQ0FBQyxPQUFPLElBQUk7QUFDWixFQUFDO0FBQ0Q7QUFDQSx3QkFBZSxDQUFDLENBQUMsS0FBSztBQUN0QixDQUFDLElBQUksSUFBSSxHQUFHO0FBQ1osRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ2YsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJO0FBQ2pCLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTztBQUNwQixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVE7QUFDckIsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLO0FBQ2xCLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUc7QUFDNUIsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUMxQixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQzFCLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVM7QUFDN0IsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSTtBQUN4QixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJO0FBQ3hCLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUs7QUFDdEIsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSztBQUN2QixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLO0FBQ3ZCLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUs7QUFDekIsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSztBQUN0QixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLO0FBQ3ZCLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUs7QUFDekIsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSztBQUM1QixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLO0FBQzNCLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEtBQUs7QUFDakMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSztBQUM3QixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLO0FBQy9CLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUs7QUFDNUIsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSztBQUMzQixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLO0FBQzVCLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUs7QUFDN0IsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSztBQUMvQixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLO0FBQzVCLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUs7QUFDN0IsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSztBQUM5QixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLO0FBQzFCLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUs7QUFDMUIsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSztBQUMxQixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLO0FBQy9CLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUs7QUFDNUIsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSztBQUM5QixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLO0FBQ3pCLEVBQUUsRUFBRSxFQUFFLENBQUMs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Ozs7Ozs7Ozs7Ozs7Ozs7MEJBSDlCLEdBQUssSUFBQyxJQUFJOzs7O29CQUVMLE1BQU0sQ0FBQyxNQUFNLGdCQUFDLEdBQVUsSUFBQyxNQUFNOzs7O2tDQUFwQyxNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0VBRkosR0FBSyxJQUFDLElBQUk7OzttQkFFTCxNQUFNLENBQUMsTUFBTSxnQkFBQyxHQUFVLElBQUMsTUFBTTs7OztpQ0FBcEMsTUFBSTs7Ozs7Ozs7Ozs7Ozs7OztzQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBTEQsTUFBTSxDQUFDLE1BQU0sZ0JBQUMsR0FBVSxJQUFDLE1BQU07Ozs7Z0NBQXBDLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQkFBQyxNQUFNLENBQUMsTUFBTSxnQkFBQyxHQUFVLElBQUMsTUFBTTs7OzsrQkFBcEMsTUFBSTs7Ozs7Ozs7Ozs7Ozs7OztvQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkNJRCxHQUFLLElBQUMsSUFBSTs7OzBCQUFJLEdBQUssSUFBQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NFQUF6QixHQUFLLElBQUMsSUFBSTtzRUFBSSxHQUFLLElBQUMsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkFKdkIsTUFBTSxDQUFDLE1BQU0sZ0JBQUMsR0FBVSxJQUFDLE1BQU07Ozs7Z0NBQXBDLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQkFBQyxNQUFNLENBQUMsTUFBTSxnQkFBQyxHQUFVLElBQUMsTUFBTTs7OzsrQkFBcEMsTUFBSTs7Ozs7Ozs7Ozs7Ozs7OztvQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0NFRyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
